{"sale.sol":{"content":"pragma solidity ^0.5.0;\n\nimport \"./token.sol\";\n\ncontract TokenSale {\n    address payable admin;\n    Token public tokenContract;\n\n\n    constructor(Token _tokenContract) public {\n        admin = msg.sender;\n        tokenContract = _tokenContract;\n    }\n\n    function buyTokens(uint256 _numberOfTokens) public payable{\n        \n        require(\n            _numberOfTokens == msg.value / 10**14,\n            \"Number of tokens does not match with the value\"\n        );\n        \n\n        require(\n            tokenContract.balanceOf(address(this)) \u003e= _numberOfTokens,\n            \"Contact does not have enough tokens\"\n        );\n        require(\n            tokenContract.transfer(msg.sender, _numberOfTokens),\n            \"Some problem with token transfer\"\n        );\n    }\n\n    function endSale() public {\n        require(msg.sender == admin, \"Only the admin can call this function\");\n        require(\n            tokenContract.transfer(\n                address(0),\n                tokenContract.balanceOf(address(this))\n            ),\n            \"Unable to transfer tokens to 0x0000\"\n        );\n        selfdestruct(admin);\n    }\n    \n    function expenses(uint256 _expenses) public {\n        require(msg.sender == admin, \"Only the admin can call this function\");\n        msg.sender.transfer(_expenses);\n    }\n    \n    function()payable external{}\n}"},"token.sol":{"content":"pragma solidity ^0.5.0;\n\ncontract Token {\n    string public name = \"FILx Token\"; \n    string public symbol = \"FILX\"; \n    uint256 public totalSupply;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    mapping(address =\u003e uint256) public balanceOf;\n    mapping(address =\u003e mapping(address =\u003e uint256)) public allowance;\n\n    constructor(uint256 _initialSupply) public {\n        balanceOf[msg.sender] = _initialSupply;\n        totalSupply = _initialSupply;\n    }\n\n    function transfer(address _to, uint256 _value)\n        public\n        returns (bool success)\n    {\n        require(balanceOf[msg.sender] \u003e= _value, \"Not enough balance\");\n        balanceOf[msg.sender] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value)\n        public\n        returns (bool success)\n    {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    ) public returns (bool success) {\n        require(\n            balanceOf[_from] \u003e= _value,\n            \"_from does not have enough tokens\"\n        );\n        require(\n            allowance[_from][msg.sender] \u003e= _value,\n            \"Spender limit exceeded\"\n        );\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        allowance[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n}"}}