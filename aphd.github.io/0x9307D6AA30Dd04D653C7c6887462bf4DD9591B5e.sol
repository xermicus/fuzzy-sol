{"Isolde.sol":{"content":"  \npragma solidity ^0.8.6;\n\n// SPDX-License-Identifier: Apache-2.0\n\nimport \"./UniswapRouter.sol\";\n\ncontract Isolde {\n    \n    modifier onlyOwner {\n        require(msg.sender == _owner, \"caller is not the owner\");\n        _;\n    }\n    \n    // tier struct\n    struct Tier {\n        string name;\n        uint8 level;\n        uint256 price;\n    }\n    \n    // events\n    event Subscribed(address wallet, uint8 level, uint256 time);\n    event Buyback(uint256 ethAmount, uint256 tokenAmount);\n    event Beacon(uint256 timestamp);\n\n    // router\n    IUniswapV2Router public router;\n    \n    // addresses \u0026 allocation\n    uint public revenueAllocation = 30;\n    address private DEAD_ADDRESS = 0x000000000000000000000000000000000000dEaD; \n    address public token;\n    address payable public treasury;\n    address private _owner;\n    \n    // subs and tiers\n    Tier[] private _tiers;\n    uint public lastSubTime = block.timestamp;\n\n    \n    constructor (address routerAddress, address tokenAddress, address payable treasuryAddress) {\n        _owner = msg.sender;\n        \n        router = IUniswapV2Router(routerAddress);\n        token = tokenAddress;\n        treasury = treasuryAddress;\n    }\n    \n    function setTiers(Tier[] memory tiers) public onlyOwner {\n        delete _tiers;\n        \n        for (uint i = 0; i \u003c tiers.length; ++i) {\n            Tier memory tier = tiers[i];\n            _tiers.push(Tier(tier.name, tier.level, tier.price));\n        }\n    }\n\n    function getTiers() public view returns (Tier[] memory) {\n        return _tiers;\n    }\n    \n    function viewTier(uint level) public view returns (string memory, uint, uint) {\n        require(level \u003e 0 \u0026\u0026 level \u003c= _tiers.length, \u0027wrong tier\u0027);\n        Tier memory tier = _tiers[level - 1];\n        return (tier.name, tier.level, tier.price);\n    }\n    \n    function subscribe(address who, uint8 level) public payable { // since who isn\u0027t msg.sender someone can possibly gift a subscribtion\n        require(level \u003e 0 \u0026\u0026 level \u003c= _tiers.length, \u0027wrong tier\u0027);\n        require(msg.value == _tiers[level - 1].price, \u0027sent ether is different from tier price\u0027);\n        \n        lastSubTime = block.timestamp;\n        emit Subscribed(who, level, 30);\n    }\n    \n    function _swapEthForTokens(uint256 ethAmount, uint256 tokenAmount) private {\n        address[] memory path = new address[](2);\n        \n        path[0] = router.WETH();\n        path[1] = token;\n\n        router.swapExactETHForTokensSupportingFeeOnTransferTokens{value: ethAmount} (\n            tokenAmount,\n            path,\n            address(DEAD_ADDRESS),\n            block.timestamp\n        );\n    }\n    \n    function _sendEthToTreasury(uint256 amount) private {\n        treasury.transfer(amount);\n    }\n    \n    function rescueEth() public onlyOwner {\n        require(block.timestamp - lastSubTime \u003e= 30 days, \u0027less than a month since last sub\u0027);\n        _sendEthToTreasury(address(this).balance);\n    }\n    \n    function buyback(uint256 ethAmount, uint256 tokenAmount) public onlyOwner {\n        require(address(this).balance \u003e= 1 ether, \u0027balance for min threshold not met\u0027);\n        require(address(this).balance \u003e= ethAmount, \u0027low balance\u0027);\n        require(token != address(0), \u0027buyback address not set\u0027);\n\n        uint256 treasuryAllocation = ethAmount * revenueAllocation / 100;\n        ethAmount = ethAmount - treasuryAllocation;\n        \n        _swapEthForTokens(ethAmount, tokenAmount);\n        _sendEthToTreasury(treasuryAllocation);\n        \n        emit Buyback(ethAmount, tokenAmount);\n    }\n    \n    function sendBeacon() public onlyOwner {\n        emit Beacon(block.timestamp);\n    }\n    \n    function setRouter(address payable newRouter) public onlyOwner {\n        router = IUniswapV2Router(newRouter);\n    }\n    \n    function setToken(address newToken) public onlyOwner {\n        token = newToken;\n    }\n    \n    function setTreasury(address payable newTreasury) public onlyOwner {\n        treasury = newTreasury;\n    }\n    \n    function setRevenueAllocation(uint newAllocation) public onlyOwner {\n        require(newAllocation \u003e 0, \u0027revenue allocation should be greater than 0\u0027);\n        require(newAllocation \u003c= 90, \u0027maximum allocation exceeded\u0027);\n        revenueAllocation = newAllocation;\n    }\n    \n    receive() external payable {}\n}"},"UniswapRouter.sol":{"content":"pragma solidity ^0.8.6;\n\n// SPDX-License-Identifier: Apache-2.0\n\ninterface IUniswapV2Router {\n    \n    function WETH() external pure returns (address);\n    \n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n}"}}