{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface KeeperCompatibleInterface {\n\n  /**\n   * @notice checks if the contract requires work to be done.\n   * @param checkData data passed to the contract when checking for upkeep.\n   * @return upkeepNeeded boolean to indicate whether the keeper should call\n   * performUpkeep or not.\n   * @return performData bytes that the keeper should call performUpkeep with,\n   * if upkeep is needed.\n   */\n  function checkUpkeep(\n    bytes calldata checkData\n  )\n    external\n    returns (\n      bool upkeepNeeded,\n      bytes memory performData\n    );\n\n  /**\n   * @notice Performs work on the contract. Executed by the keepers, via the registry.\n   * @param performData is the data which was passed back from the checkData\n   * simulation.\n   */\n  function performUpkeep(\n    bytes calldata performData\n  ) external;\n}\n"
    },
    "contracts/EthroneContract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"@chainlink/contracts/src/v0.8/interfaces/KeeperCompatibleInterface.sol\";\n\n/**\n * @title EthroneContract\n * @dev Manages the Ethrone game contract\n *\n * Rules:\n * fixed amount to enter (low) goes into prize pool\n * only one player can take the throne per block\n * players can only capture the throne `maxAttempts` times per round (default: 3)\n * time spent accumulates for the user everytimes they takes over the throne\n * a round lasts `roundDuration` seconds (default: 24h)\n * at the end of the round - prizepool goes to user who spent the most time on the Throne\n * if multiple top users with the same time spent -> the first player that has reached the time gets the prize\n */\ncontract EthroneContract is KeeperCompatibleInterface {\n\n    uint8 public immutable maxAttempts;\n    uint32 public immutable roundDuration;\n    address public immutable contractOwner;\n    uint256 public immutable throneCost;\n\n    uint256 public lastRoundStartTime;\n    uint32 public round;\n    address public lastWinner;\n    ThroneOwner public currentThroneOwner;\n    address[] public participants;\n    mapping (address => uint32) timeSpentMapping;\n    mapping (address => uint8) attemptsMapping;\n\n    event ThroneTaken(address prevOwner, address newOwner, uint32 prevOwnerTimeSpent, uint32 round);\n    event WinnerChosen(address winner, uint256 prize, uint32 totalTimeSpent, uint32 round, uint32 totalPlayers);\n\n    struct ThroneOwner {\n        address user;\n        uint256 timestamp;\n        bytes32 hash;\n    }\n\n    constructor(uint32 duration, uint8 maxAttemptsPerPlayer, uint256 cost) {\n        contractOwner = msg.sender;\n        round = 1;\n        roundDuration = duration;\n        lastRoundStartTime = block.timestamp;\n        maxAttempts = maxAttemptsPerPlayer;\n        throneCost = cost;\n    }\n\n    // Keeper interface\n\n    function checkUpkeep(bytes calldata /* checkData */) external override returns (bool upkeepNeeded, bytes memory /* performData */) {\n        upkeepNeeded = (block.timestamp - lastRoundStartTime) > roundDuration;\n    }\n\n    function performUpkeep(bytes calldata /* performData */) external override {\n        awardPrize();\n    }\n\n    // Game public methods   \n\n    /**\n      Main game function\n     */\n    function takeThrone() public payable {\n        require(msg.value == throneCost, \"Exactly 0.01 ether is required to take the Ethrone\"); // mandatory fixed price\n        require((block.timestamp - lastRoundStartTime) < roundDuration, \"The round is over! Wait for the next one to start\");\n        // contractOwner cannot take the throne\n        address newOwner = msg.sender;\n        require(newOwner != currentThroneOwner.user, \"You already own the Ethrone!\");\n        require(newOwner != contractOwner, \"The contract owner is not allowed to play\");\n\n        // reject transaction if the current owner already owns this block\n        bytes32 currentHash = blockhash(block.number - 1);\n        require(currentThroneOwner.hash != currentHash, \"The throne is already taken for this block!\");\n\n        // reject transaction if player already reached the max attempts this round\n        require(attemptsMapping[newOwner] < maxAttempts, \"You have reached the maximum attempts for this round\");\n\n        // record new participant if not already recorded\n        if (attemptsMapping[newOwner] == 0) {\n          participants.push(newOwner);\n        }\n\n        // increment attempts for player\n        attemptsMapping[newOwner] = attemptsMapping[newOwner] + 1;        \n\n        // record time for last owner\n        updateLastTimeSpent();\n\n        // set the new owner\n        address previousOwner = currentThroneOwner.user;\n        currentThroneOwner = ThroneOwner(newOwner, block.timestamp, currentHash);\n        emit ThroneTaken(previousOwner, newOwner, accumulatedTimeSpent(previousOwner), round);\n    }\n\n    /**\n     * Find the winner of the round and transfers the prize to it\n     */\n    function awardPrize() public {\n        require((block.timestamp - lastRoundStartTime) > roundDuration, \"The round is not over yet!\");\n        \n        // find winner\n        uint32 participantSize = uint32(participants.length);\n        uint32 longestTimeSpent = 0;\n        address winner;\n\n        // no players this round, start the next one\n        if (participantSize == 0) {\n            resetGameAndStartNextRound();\n            return;\n        }\n\n        // update last owner's time spent\n        updateLastTimeSpent();\n\n        // find the winner address\n        for (uint32 i = 0; i < participantSize; i++) {\n            address participant = participants[i];\n            uint32 timeSpent = timeSpentMapping[participant];\n            if (timeSpent > longestTimeSpent && participant != contractOwner) {\n                winner = participant;\n                longestTimeSpent = timeSpent;\n            }\n        }\n\n        // assert valid winner\n        require(winner != address(0x0), \"Did not find a winner\");\n        require(winner != contractOwner, \"Winner cannot be the owner\");\n        // transfer prize\n        uint256 totalPrize = currentPrizePool();\n        uint256 winnerPrize = totalPrize * 90 / 100; // 90% for the winner\n        uint256 maintenanceBudget = totalPrize - winnerPrize; // 10% for maintenance costs\n        payable(winner).transfer(winnerPrize);\n        payable(contractOwner).transfer(maintenanceBudget);\n        lastWinner = winner;\n        emit WinnerChosen(winner, winnerPrize, accumulatedTimeSpent(winner), round, participantSize);\n\n        // cleanup and start next round\n        resetGameAndStartNextRound();\n    }\n\n    /**\n     * The total prize pool for this round\n     */\n    function currentPrizePool() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * The time spent by the last owner\n     */\n    function currentTimeSpent() public view returns (uint32) {\n        return uint32(block.timestamp - currentThroneOwner.timestamp);\n    }\n\n    /**\n     * The address of the current owner\n     */\n    function currentOwner() public view returns (address) {\n      return currentThroneOwner.user;\n    }\n\n    /**\n     * The previous time spent for a given address (excluding current)\n     */\n    function accumulatedTimeSpent(address user) public view returns (uint32) {\n        return timeSpentMapping[user];\n    }\n\n    /**\n     * The total time spent (including current) for the given address\n     */\n    function totalTimeSpent(address user) public view returns (uint32) {\n        if (user == currentThroneOwner.user) {\n          return currentTimeSpent() + accumulatedTimeSpent(user);\n        }\n        return accumulatedTimeSpent(user);\n    }\n\n    /**\n     * Total number of participants for this round\n     */\n    function totalParticipants() public view returns (uint32) {\n        return uint32(participants.length);\n    }\n\n    /**\n     * The amount of time since current round started\n     */\n    function currentRoundTime() public view returns (uint32) {\n        return uint32(block.timestamp - lastRoundStartTime);\n    }\n\n    /**\n     * The number of attempts for a given player this round\n     */\n    function numberOfAttemts(address user) public view returns (uint8) {\n        return attemptsMapping[user];\n    }\n\n    // PRIVATE\n\n    /**\n     * Records the time spent for the current owner \n     */\n    function updateLastTimeSpent() private {\n        address user = currentThroneOwner.user;\n        if (user != address(0x0)) {\n          uint256 timeTaken = currentThroneOwner.timestamp;\n          timeSpentMapping[user] += uint32(block.timestamp - timeTaken);\n        }\n    }\n\n    function resetGameAndStartNextRound() private {\n        uint32 participantSize = uint32(participants.length);\n        for (uint32 i = 0; i < participantSize; i++) {\n            address participant = participants[i];\n            delete timeSpentMapping[participant]; // clear mapping entry\n            delete attemptsMapping[participant];\n        }\n        delete participants; // clear all participants\n        delete currentThroneOwner; // reset current owner\n\n        // prepare for new round\n        round = round + 1;\n        lastRoundStartTime = block.timestamp;\n    }\n\n    // modifier to check if caller is owner\n    modifier isOwner() {\n        require(msg.sender == contractOwner, \"Caller is not owner\");\n        _;\n    }\n}"
    }
  }
}}