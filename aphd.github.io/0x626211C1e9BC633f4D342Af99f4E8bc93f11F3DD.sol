{"FactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\nimport \"IQueryableFactRegistry.sol\";\n\ncontract FactRegistry is IQueryableFactRegistry {\n    // Mapping: fact hash -\u003e true.\n    mapping (bytes32 =\u003e bool) private verifiedFact;\n\n    // Indicates whether the Fact Registry has at least one fact registered.\n    bool anyFactRegistered;\n\n    /*\n      Checks if a fact has been verified.\n    */\n    function isValid(bytes32 fact)\n        external view override\n        returns(bool)\n    {\n        return _factCheck(fact);\n    }\n\n\n    /*\n      This is an internal method to check if the fact is already registered.\n      In current implementation of FactRegistry it\u0027s identical to isValid().\n      But the check is against the local fact registry,\n      So for a derived referral fact registry, it\u0027s not the same.\n    */\n    function _factCheck(bytes32 fact)\n        internal view\n        returns(bool)\n    {\n        return verifiedFact[fact];\n    }\n\n    function registerFact(\n        bytes32 factHash\n        )\n        internal\n    {\n        // This function stores the fact hash in the mapping.\n        verifiedFact[factHash] = true;\n\n        // Mark first time off.\n        if (!anyFactRegistered) {\n            anyFactRegistered = true;\n        }\n    }\n\n    /*\n      Indicates whether at least one fact was registered.\n    */\n    function hasRegisteredFact()\n        external view override\n        returns(bool)\n    {\n        return anyFactRegistered;\n    }\n\n}\n"},"Identity.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\ninterface Identity {\n\n    /*\n      Allows a caller, typically another contract,\n      to ensure that the provided address is of the expected type and version.\n    */\n    function identify()\n        external pure\n        returns(string memory);\n}\n"},"IFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\n/*\n  The Fact Registry design pattern is a way to separate cryptographic verification from the\n  business logic of the contract flow.\n\n  A fact registry holds a hash table of verified \"facts\" which are represented by a hash of claims\n  that the registry hash check and found valid. This table may be queried by accessing the\n  isValid() function of the registry with a given hash.\n\n  In addition, each fact registry exposes a registry specific function for submitting new claims\n  together with their proofs. The information submitted varies from one registry to the other\n  depending of the type of fact requiring verification.\n\n  For further reading on the Fact Registry design pattern see this\n  `StarkWare blog post \u003chttps://medium.com/starkware/the-fact-registry-a64aafb598b6\u003e`_.\n*/\ninterface IFactRegistry {\n    /*\n      Returns true if the given fact was previously registered in the contract.\n    */\n    function isValid(bytes32 fact)\n        external view\n        returns(bool);\n}\n"},"IQueryableFactRegistry.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\nimport \"IFactRegistry.sol\";\n\n/*\n  Extends the IFactRegistry interface with a query method that indicates\n  whether the fact registry has successfully registered any fact or is still empty of such facts.\n*/\ninterface IQueryableFactRegistry is IFactRegistry {\n\n    /*\n      Returns true if at least one fact has been registered.\n    */\n    function hasRegisteredFact()\n        external view\n        returns(bool);\n\n}\n"},"PedersenMerkleVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\ncontract PedersenMerkleVerifier {\n\n    // Note that those values are hardcoded in the assembly.\n    uint256 constant internal N_TABLES = 63;\n\n    address[N_TABLES] lookupTables;\n    constructor(address[N_TABLES] memory tables) public {\n        lookupTables = tables;\n\n        assembly {\n            if gt(lookupTables_slot, 0) {\n                // The address of the lookupTables must be 0.\n                // This is guaranteed by the ABI, as long as it is the first storage variable.\n                // This is an assumption in the implementation, and can be removed if\n                // the lookup table address is taken into account.\n                revert(0, 0)\n            }\n\n        }\n    }\n\n    /**\n      Verifies a merkle proof for a Merkle commitment.\n\n      The Merkle commitment uses the Pedersen hash variation described next:\n\n      - **Hash constants:** A sequence :math:`p_i` of 504 points on an elliptic curve and an additional :math:`ec_{shift}` point\n      - **Input:** A vector of 504 bits :math:`b_i`\n      - **Output:** The 252 bits x coordinate of :math:`(ec_{shift} + \\sum_i b_i*p_i)`\n\n      The following table describes the expected `merkleProof` format. Note that unlike a standard\n      Merkle proof, the `merkleProof` contains both the nodes along the Merkle path and their\n      siblings. The proof ends with the expected root and the ID of the vault for which the proof is\n      submitted (which implies the location of the nodes within the Merkle tree).\n\n          +-------------------------------+---------------------------+-----------+\n          | left_node_0 (252)             | right_node_0 (252)        | zeros (8) |\n          +-------------------------------+---------------------------+-----------+\n          | ...                                                                   |\n          +-------------------------------+---------------------------+-----------+\n          | left_node_n (252)             | right_node_n (252)        | zeros (8) |\n          +-------------------------------+-----------+---------------+-----------+\n          | root (252)                    | zeros (4) | nodeIdx (248) | zeros (8) |\n          +-------------------------------+-----------+---------------+-----------+\n\n\n      Note that if the merkle leafs are computed using a hashchain as follows:\n        hashchain_state = init_state\n        for value in leaf_values:\n            hashchain_state = pedersen_hash(hashchain_state, value)\n        leaf_value = hashchain_state\n\n      Then we may use this function to verify the leaf value by setting:\n      nodeIdx = merkle_idx \u003c\u003c hashchain_lengh and for every 0 \u003c= i \u003c hashchain_lengh.\n      left_node_0 = hashchain_state_i\n      right_node_i = leaf_values_i.\n\n    */\n    /*\n      Implementation details:\n      The EC sum required for the hash computation is computed using lookup tables and EC additions.\n      There are 63 lookup tables and each table contains all the possible subset sums of the\n      corresponding 8 EC points in the hash definition.\n\n      Both the full subset sum and the tables are shifted to avoid a special case for the 0 point.\n      lookupTables[0] uses the offset 2^62*ec_shift and lookupTables[k] for k \u003e 0 uses\n      the offset 2^(62-k)*(-ec_shift).\n      Note that the sum of the shifts of all the tables is exactly the shift required for the\n      hash. Moreover, the partial sums of those shifts are never 0.\n\n      The calls to the lookup table contracts are batched to save on gas cost.\n      We allocate a table of N_HASHES by N_TABLES EC elements.\n      Fill the i\u0027th row by calling the i\u0027th lookup contract to lookup the i\u0027th byte in each hash and\n      then compute the j\u0027th hash by summing the j\u0027th column.\n\n                  N_HASHES\n              --------------\n              |            |\n              |            |\n              |            |\n              |            | N_TABLES\n              |            |\n              |            |\n              |            |\n              |            |\n              --------------\n\n      The batched lookup is facilitated by the fact that the merkleProof includes nodes along the\n      Merkle path.\n      However having this redundant information requires us to do consistency checks\n      to ensure we indeed verify a coherent authentication path:\n\n          hash((left_node_{i-1}, right_node_{i-1})) ==\n            (nodeIdx \u0026 (1\u003c\u003ci)) == 0 ? left_node_i : right_node_i.\n    */\n    function verifyMerkle(uint256[] memory merkleProof) internal view {\n        uint256 proofLength = merkleProof.length;\n\n        // The minimal supported proof length is for a tree height of 1 in a 4 word representation as follows:\n        // 1 word pairs representing the authentication path.\n        // 1 word pair representing the root and the nodeIdx.\n        require(proofLength \u003e= 4, \"Proof too short.\");\n\n        // The contract supports verification paths of lengths up to 200 in a 402 word representation as described above.\n        // This limitation is imposed in order to avoid potential attacks.\n        require(proofLength \u003c= 402, \"Proof too long.\");\n\n        // Ensure proofs are always a series of word pairs.\n        require((proofLength \u0026 1) == 0, \"Proof length must be even.\");\n\n        // Each hash takes 2 256bit words and the last two words are the root and nodeIdx.\n        uint256 height = (proofLength - 2) / 2; // NOLINT: divide-before-multiply.\n\n        // Note that it is important to limit the range of vault id, to make sure\n        // we use the left node (== merkle_root) in the last iteration of the loop below.\n\n        uint256 nodeIdx = merkleProof[proofLength - 1] \u003e\u003e 8;\n        require(nodeIdx \u003c 2**height, \"nodeIdx not in tree.\");\n        require((nodeIdx \u0026 1) == 0, \"nodeIdx must be even.\");\n\n        uint256 rowSize = (2 * height) * 0x20;\n        uint256[] memory proof = merkleProof;\n        assembly {\n            // Skip the length of the proof array.\n            proof := add(proof, 0x20)\n\n            function raise_error(message, msg_len) {\n                // Solidity generates reverts with reason that look as follows:\n                // 1. 4 bytes with the constant 0x08c379a0 (== Keccak256(b\u0027Error(string)\u0027)[:4]).\n                // 2. 32 bytes offset bytes (typically 0x20).\n                // 3. 32 bytes with the length of the revert reason.\n                // 4. Revert reason string.\n\n                mstore(0, 0x08c379a000000000000000000000000000000000000000000000000000000000)\n                mstore(0x4, 0x20)\n                mstore(0x24, msg_len)\n                mstore(0x44, message)\n                revert(0, add(0x44, msg_len))\n            }\n\n            let left_node := shr(4, mload(proof))\n            let right_node := and(mload(add(proof, 0x1f)),\n                               0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\n            let primeMinusOne := 0x800000000000011000000000000000000000000000000000000000000000000\n            if or(gt(left_node, primeMinusOne), gt(right_node, primeMinusOne)) {\n                raise_error(\"Bad starkKey or assetId.\", 24)\n            }\n\n            let nodeSelectors := nodeIdx\n\n            // Allocate EC points table with dimensions N_TABLES by N_HASHES.\n            let table := mload(0x40)\n            let tableEnd := add(table, mul(rowSize, /*N_TABLES*/63))\n\n            // for i = 0..N_TABLES-1, fill the i\u0027th row in the table.\n            for { let i := 0 } lt(i, 63) { i := add(i, 1)} {\n                if iszero(staticcall(gas(), sload(i), add(proof, i), rowSize,\n                                     add(table, mul(i, rowSize)), rowSize)) {\n                   returndatacopy(0, 0, returndatasize())\n                   revert(0, returndatasize())\n                }\n            }\n\n            // The following variables are allocated above PRIME to avoid the stack too deep error.\n            // Byte offset used to access the table and proof.\n            let offset := 0\n            let ptr\n            let aZ\n\n            let PRIME := 0x800000000000011000000000000000000000000000000000000000000000001\n\n            // For k = 0..HASHES-1, Compute the k\u0027th hash by summing the k\u0027th column in table.\n            // Instead of k we use offset := k * sizeof(EC point).\n            // Additonally we use ptr := offset + j * rowSize to ge over the EC points we want\n            // to sum.\n            for { } lt(offset, rowSize) { } {\n                // Init (aX, aY, aZ) to the first value in the current column and sum over the\n                // column.\n                ptr := add(table, offset)\n                aZ := 1\n                let aX := mload(ptr)\n                let aY := mload(add(ptr, 0x20))\n\n                for { ptr := add(ptr, rowSize) } lt(ptr, tableEnd)\n                    { ptr:= add(ptr, rowSize) } {\n\n                    let bX := mload(ptr)\n                    let bY := mload(add(ptr, 0x20))\n\n                    // Set (aX, aY, aZ) to be the sum of the EC points (aX, aY, aZ) and (bX, bY, 1).\n                    let minusAZ := sub(PRIME, aZ)\n                    // Slope = sN/sD =  {(aY/aZ) - (bY/1)} / {(aX/aZ) - (bX/1)}.\n                    // sN = aY - bY * aZ.\n                    let sN := addmod(aY, mulmod(minusAZ, bY, PRIME), PRIME)\n\n                    let minusAZBX := mulmod(minusAZ, bX, PRIME)\n                    // sD = aX - bX * aZ.\n                    let sD := addmod(aX, minusAZBX, PRIME)\n\n                    let sSqrD := mulmod(sD, sD, PRIME)\n\n                    // Compute the (affine) x coordinate of the result as xN/xD.\n\n                    // (xN/xD) = ((sN)^2/(sD)^2) - (aX/aZ) - (bX/1).\n                    // xN = (sN)^2 * aZ - aX * (sD)^2 - bX * (sD)^2 * aZ.\n                    // = (sN)^2 * aZ + (sD^2) (bX * (-aZ) - aX).\n                    let xN := addmod(mulmod(mulmod(sN, sN, PRIME), aZ, PRIME),\n                                    mulmod(sSqrD,\n                                            add(minusAZBX, sub(PRIME, aX)),\n                                            PRIME),\n                                    PRIME)\n\n                    // xD = (sD)^2 * aZ.\n                    let xD := mulmod(sSqrD, aZ, PRIME)\n\n                    // Compute (aX\u0027, aY\u0027, aZ\u0027) for the next iteration and assigning them to (aX, aY, aZ).\n                    // (y/z) = (sN/sD) * {(bX/1) - (xN/xD)} - (bY/1).\n                    // aZ\u0027 = sD*xD.\n                    aZ := mulmod(sD, xD, PRIME)\n                    // aY\u0027 = sN*(bX * xD - xN) - bY*z = -bY * z + sN * (-xN + xD*bX).\n                    aY := addmod(sub(PRIME, mulmod(bY, aZ, PRIME)),\n                                    mulmod(sN,\n                                    add(sub(PRIME, xN),\n                                        mulmod(xD, bX, PRIME)),\n                                    PRIME),\n                                PRIME)\n\n                    // As the value of the affine x coordinate is xN/xD and z=sD*xD,\n                    // the projective x coordinate is xN*sD.\n                    aX := mulmod(xN, sD, PRIME)\n                }\n\n                // At this point proof[offset + 0x40] holds the next input to be hashed.\n                // This input is typically in the form left_node||right_node||0 and\n                // we need to extract the relevant node for the consistent check below.\n                // Note that the same logic is reused for the leaf computation and\n                // for the consistent check with the final root.\n                offset := add(offset, 0x40)\n\n                // Init expected_hash to left_node.\n                // It will be replaced by right_node if necessary.\n                let expected_hash := shr(4, mload(add(proof, offset)))\n\n                let other_node := and(  // right_node\n                    mload(add(proof, add(offset, 0x1f))),\n                    0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n\n                // Make sure both nodes are in the range [0, PRIME - 1].\n                if or(gt(expected_hash, primeMinusOne), gt(other_node, primeMinusOne)) {\n                    raise_error(\"Value out of range.\", 19)\n                }\n\n                nodeSelectors := shr(1, nodeSelectors)\n                if and(nodeSelectors, 1) {\n                    expected_hash := other_node\n                }\n\n                // Make sure the result is consistent with the Merkle path.\n                // I.e (aX/aZ) == expected_hash,\n                // where expected_hash = (nodeSelectors \u0026 1) == 0 ? left_node : right_node.\n                // We also make sure aZ is not 0. I.e. during the summation we never tried\n                // to add two points with the same x coordinate.\n                // This is not strictly necessary because knowing how to trigger this condition\n                // implies knowing a non-trivial linear equation on the random points defining the\n                // hash function.\n                if iszero(aZ) {\n                   raise_error(\"aZ is zero.\", 11)\n                }\n\n                if sub(aX, mulmod(expected_hash, aZ, PRIME))/*!=0*/ {\n                   raise_error(\"Bad Merkle path.\", 16)\n                }\n            }\n        }\n    }\n}\n"},"PerpetualEscapeVerifier.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\nimport \"FactRegistry.sol\";\nimport \"PedersenMerkleVerifier.sol\";\nimport \"Identity.sol\";\nimport \"ProgramOutputOffsets.sol\";\n\n/*\n  A PerpetualEscapeVerifier is a fact registry contract for claims of the form:\n    The owner of \u0027publicKey\u0027 may withdraw \u0027withdrawalAmount\u0027 qunatized collateral units\n    from \u0027positionId\u0027 assuming the hash of the shared state is \u0027sharedStateHash\u0027\n\n  The fact is encoded as:\n    keccak256(abi.encodePacked(\n        publicKey, withdrawalAmount, sharedStateHash, positionId).\n*/\ncontract PerpetualEscapeVerifier is\n    PedersenMerkleVerifier, FactRegistry,\n    Identity, ProgramOutputOffsets {\n    event LogEscapeVerified(\n        uint256 publicKey,\n        int256 withdrawalAmount,\n        bytes32 sharedStateHash,\n        uint256 positionId\n    );\n\n    uint256 internal constant N_ASSETS_BITS = 16;\n    uint256 internal constant BALANCE_BITS = 64;\n    uint256 internal constant FUNDING_BITS = 64;\n    uint256 internal constant BALANCE_BIAS = 2**63;\n    uint256 internal constant FXP_BITS = 32;\n\n    uint256 internal constant FUNDING_ENTRY_SIZE = 2;\n    uint256 internal constant PRICE_ENTRY_SIZE = 2;\n\n    constructor(address[N_TABLES] memory tables)\n        PedersenMerkleVerifier(tables)\n        public\n    {\n    }\n\n    function identify()\n        external pure override virtual\n        returns(string memory)\n    {\n        return \"StarkWare_PerpetualEscapeVerifier_2021_2\";\n    }\n\n    /*\n      Finds an entry corresponding to assetId in the slice array[startIdx:endIdx].\n      Assumes that size of each entry is 2 and that the key is in offset 0 of an entry.\n    */\n    function findAssetId(\n        uint256 assetId, uint256[] memory array, uint256 startIdx, uint256 endIdx)\n        internal pure returns (uint256 idx) {\n        idx = startIdx;\n        while(array[idx] != assetId) {\n            idx += /*entry_size*/2;\n            require(idx \u003c endIdx, \"assetId not found.\");\n        }\n    }\n\n\n    /*\n      Computes the balance of the position according to the sharedState.\n\n      Assumes the position is given as\n      [\n       positionAsset_0, positionAsset_1, ..., positionAsset_{n_assets},\n       publicKey, biasedBalance \u003c\u003c N_ASSETS_BITS | nAssets,\n      ]\n      where positionAsset_{i} is encoded as\n         assedId \u003c\u003c 128 | cachedFunding \u003c\u003c BALANCE_BITS | biased_asset_balance.\n\n    */\n    function computeFxpBalance(\n        uint256[] memory position, uint256[] memory sharedState)\n        internal pure returns (int256) {\n\n        uint256 nAssets;\n        uint256 fxpBalance;\n\n        {\n            // Decode collateral_balance and nAssets.\n            uint256 lastWord = position[position.length - 1];\n            nAssets = lastWord \u0026 ((1 \u003c\u003c N_ASSETS_BITS) - 1);\n            uint256 biasedBalance = lastWord \u003e\u003e N_ASSETS_BITS;\n\n            require(position.length == nAssets + 2, \"Bad number of assets.\");\n            require(biasedBalance \u003c 2**BALANCE_BITS, \"Bad balance.\");\n\n            fxpBalance = (biasedBalance - BALANCE_BIAS) \u003c\u003c FXP_BITS;\n        }\n\n        uint256 fundingIndicesOffset = STATE_OFFSET_FUNDING;\n        uint256 nFundingIndices = sharedState[fundingIndicesOffset - 1];\n\n        uint256 fundingEnd = fundingIndicesOffset + FUNDING_ENTRY_SIZE * nFundingIndices;\n\n        // Skip global_funding_indices.timestamp and nPrices.\n        uint256 pricesOffset = fundingEnd + 2;\n        uint256 nPrices = sharedState[pricesOffset - 1];\n        uint256 pricesEnd = pricesOffset + PRICE_ENTRY_SIZE * nPrices;\n        // Copy sharedState ptr to workaround stack too deep.\n        uint256[] memory sharedStateCopy = sharedState;\n\n        uint256 fundingTotal = 0;\n        for (uint256 i = 0; i \u003c nAssets; i++) {\n            // Decodes a positionAsset (See encoding in the function description).\n            uint256 positionAsset = position[i];\n            uint256 assedId = positionAsset \u003e\u003e 128;\n\n            // Note that the funding_indices in both the position and the shared state\n            // are biased by the same amount.\n            uint256 cachedFunding = (positionAsset \u003e\u003e BALANCE_BITS) \u0026 (2**FUNDING_BITS - 1);\n            uint256 assetBalance = (positionAsset \u0026 (2**BALANCE_BITS - 1)) - BALANCE_BIAS;\n\n            fundingIndicesOffset = findAssetId(\n                assedId, sharedStateCopy, fundingIndicesOffset, fundingEnd);\n            fundingTotal -= assetBalance *\n                (sharedStateCopy[fundingIndicesOffset + 1] - cachedFunding);\n\n            pricesOffset = findAssetId(assedId, sharedStateCopy, pricesOffset, pricesEnd);\n            fxpBalance += assetBalance * sharedStateCopy[pricesOffset + 1];\n        }\n\n        uint256 truncatedFunding = fundingTotal \u0026 ~(2**FXP_BITS - 1);\n        return int256(fxpBalance + truncatedFunding);\n    }\n\n\n    /*\n      Extracts the position from the escapeProof.\n\n      Assumes the position is encoded in the first (nAssets + 2) right nodes in the merkleProof.\n      and that each pair of nodes is encoded in 2 256bits words as follows:\n      +-------------------------------+---------------------------+-----------+\n      | left_node_i (252)             | right_node_i (252)        | zeros (8) |\n      +-------------------------------+---------------------------+-----------+\n\n      See PedersenMerkleVerifier.sol for more details.\n    */\n    function extractPosition(uint256[] memory merkleProof, uint256 nAssets)\n        internal pure\n        returns (uint256 positionId, uint256[] memory position) {\n\n        require((merkleProof[0] \u003e\u003e 8) == 0, \u0027Position hash-chain must start with 0.\u0027);\n\n        uint256 positionLength = nAssets + 2;\n        position = new uint256[](positionLength);\n        uint256 nodeIdx = merkleProof[merkleProof.length - 1] \u003e\u003e 8;\n\n        // Check that the merkleProof starts with a hash_chain of \u0027positionLength\u0027 elements.\n        require(\n            (nodeIdx \u0026 ((1 \u003c\u003c positionLength) - 1)) == 0,\n            \"merkleProof is inconsistent with nAssets.\");\n        positionId = nodeIdx \u003e\u003e positionLength;\n\n        assembly {\n            let positionPtr := add(position, 0x20)\n            let positionEnd := add(positionPtr, mul(mload(position), 0x20))\n            let proofPtr := add(merkleProof, 0x3f)\n\n            for { } lt(positionPtr, positionEnd)  { positionPtr := add(positionPtr, 0x20) } {\n                mstore(positionPtr, and(mload(proofPtr),\n                       0x0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff))\n                proofPtr := add(proofPtr, 0x40)\n            }\n        }\n    }\n\n\n    /*\n      Verifies an escape and registers the corresponding fact as\n        keccak256(abi.encodePacked(\n            publicKey, withdrawalAmount, sharedStateHash, positionId)).\n\n      The escape verification has two parts:\n        a. verifying that a certain position belongs to the position tree in the shared state.\n        b. computing the amount that may be withdrawan from that position.\n\n      Part a is delegated to the PedersenMerkleVerifier.\n      To this end the position is encoded in the prefix of the merkleProof and the node_selector at\n      the end of the merkleProof is adjusted accordingly.\n    */\n    function verifyEscape(\n        uint256[] calldata merkleProof, uint256 nAssets, uint256[] calldata sharedState) external {\n        (uint256 positionId, uint256[] memory position) = extractPosition(merkleProof, nAssets);\n\n        int256 withdrawalAmount = computeFxpBalance(position, sharedState) \u003e\u003e FXP_BITS;\n\n        // Each hash takes 2 256bit words and the last two words are the root and nodeIdx.\n        uint256 nHashes = (merkleProof.length - 2) / 2; // NOLINT: divide-before-multiply.\n        uint256 positionTreeHeight = nHashes - position.length;\n\n        require(\n            sharedState[STATE_OFFSET_VAULTS_ROOT] == (merkleProof[merkleProof.length - 2] \u003e\u003e 4),\n            \"merkleProof is inconsistent with the root in the sharedState.\");\n\n        require(\n            sharedState[STATE_OFFSET_VAULTS_HEIGHT] == positionTreeHeight,\n            \"merkleProof is inconsistent with the height in the sharedState.\");\n\n        require(withdrawalAmount \u003e 0, \"Withdrawal amount must be positive.\");\n        bytes32 sharedStateHash = keccak256(abi.encodePacked(sharedState));\n\n        uint256 publicKey = position[nAssets];\n        emit LogEscapeVerified(publicKey, withdrawalAmount, sharedStateHash, positionId);\n        bytes32 fact = keccak256(\n            abi.encodePacked(\n            publicKey, withdrawalAmount, sharedStateHash, positionId));\n\n        verifyMerkle(merkleProof);\n\n        registerFact(fact);\n    }\n}\n"},"ProgramOutputOffsets.sol":{"content":"/*\n  Copyright 2019,2020 StarkWare Industries Ltd.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\").\n  You may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n  https://www.starkware.co/open-source-license/\n\n  Unless required by applicable law or agreed to in writing,\n  software distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions\n  and limitations under the License.\n*/\n// SPDX-License-Identifier: Apache-2.0.\npragma solidity ^0.6.11;\n\ncontract ProgramOutputOffsets {\n    // The following constants are offsets of data expected in the program output.\n    // The offsets here are of the fixed fields.\n    uint256 internal constant PROG_OUT_GENERAL_CONFIG_HASH = 0;\n    uint256 internal constant PROG_OUT_N_ASSET_CONFIGS = 1;\n    uint256 internal constant PROG_OUT_ASSET_CONFIG_HASHES = 2;\n\n    /*\n      Additional mandatory fields of a single word:\n      - Previous state size         2\n      - New state size              3\n      - Vault tree height           4\n      - Order tree height           5\n      - Expiration timestamp        6\n      - No. of Modifications        7.\n    */\n    uint256 internal constant PROG_OUT_N_WORDS_MIN_SIZE = 8;\n\n    uint256 internal constant PROG_OUT_N_WORDS_PER_ASSET_CONFIG = 2;\n    uint256 internal constant PROG_OUT_N_WORDS_PER_MODIFICATION = 3;\n\n    uint256 internal constant ASSET_CONFIG_OFFSET_ASSET_ID = 0;\n    uint256 internal constant ASSET_CONFIG_OFFSET_CONFIG_HASH = 1;\n\n    uint256 internal constant MODIFICATIONS_OFFSET_STARKKEY = 0;\n    uint256 internal constant MODIFICATIONS_OFFSET_POS_ID = 1;\n    uint256 internal constant MODIFICATIONS_OFFSET_BIASED_DIFF = 2;\n\n    uint256 internal constant STATE_OFFSET_VAULTS_ROOT = 0;\n    uint256 internal constant STATE_OFFSET_VAULTS_HEIGHT = 1;\n    uint256 internal constant STATE_OFFSET_ORDERS_ROOT = 2;\n    uint256 internal constant STATE_OFFSET_ORDERS_HEIGHT = 3;\n    uint256 internal constant STATE_OFFSET_N_FUNDING = 4;\n    uint256 internal constant STATE_OFFSET_FUNDING = 5;\n\n    // The following constants are offsets of data expected in the application data.\n    uint256 internal constant APP_DATA_BATCH_ID_OFFSET = 0;\n    uint256 internal constant APP_DATA_PREVIOUS_BATCH_ID_OFFSET = 1;\n    uint256 internal constant APP_DATA_N_CONDITIONAL_TRANSFER = 2;\n    uint256 internal constant APP_DATA_CONDITIONAL_TRANSFER_DATA_OFFSET = 3;\n    uint256 internal constant APP_DATA_N_WORDS_PER_CONDITIONAL_TRANSFER = 2;\n}\n"}}