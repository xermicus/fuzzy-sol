{"ERC20.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn\u0027t required by the specification.\r\n *\r\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\r\n * functions have been added to mitigate the well-known issues around setting\r\n * allowances. See `IERC20.approve`.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address =\u003e uint256) internal _balances;\r\n\r\n    mapping (address =\u003e mapping (address =\u003e uint256)) private _allowances;\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) public view returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) public returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function increaseAllowance(address spender, uint256 addedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\r\n     *\r\n     * This is an alternative to `approve` that can be used as a mitigation for\r\n     * problems described in `IERC20.approve`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `spender` must have allowance for the caller of at least\r\n     * `subtractedValue`.\r\n     */\r\n    function decreaseAllowance(address spender, uint256 subtractedValue) public returns (bool) {\r\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].sub(subtractedValue));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal {\r\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\r\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\r\n\r\n        _balances[sender] = _balances[sender].sub(amount);\r\n        _balances[recipient] = _balances[recipient].add(amount);\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`\u0027s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function _transferFrom(address sender, address recipient, uint256 amount) internal {\r\n        _transfer(sender, recipient, amount);\r\n        _approve(sender, msg.sender, _allowances[sender][msg.sender].sub(amount));\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address account, uint256 amount) internal {\r\n        require(account != address(0), \"ERC20: mint to the zero address\");\r\n\r\n        _totalSupply = _totalSupply.add(amount);\r\n        _balances[account] = _balances[account].add(amount);\r\n        emit Transfer(address(0), account, amount);\r\n    }\r\n\r\n     /**\r\n     * @dev Destoys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `account` cannot be the zero address.\r\n     * - `account` must have at least `amount` tokens.\r\n     */\r\n    function _burn(address account, uint256 value) internal {\r\n        require(account != address(0), \"ERC20: burn from the zero address\");\r\n\r\n        _totalSupply = _totalSupply.sub(value);\r\n        _balances[account] = _balances[account].sub(value);\r\n        emit Transfer(account, address(0), value);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `owner` cannot be the zero address.\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        require(owner != address(0), \"ERC20: approve from the zero address\");\r\n        require(spender != address(0), \"ERC20: approve to the zero address\");\r\n\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Destoys `amount` tokens from `account`.`amount` is then deducted\r\n     * from the caller\u0027s allowance.\r\n     *\r\n     * See `_burn` and `_approve`.\r\n     */\r\n    function _burnFrom(address account, uint256 amount) internal {\r\n        _burn(account, amount);\r\n        _approve(account, msg.sender, _allowances[account][msg.sender].sub(amount));\r\n    }\r\n}\r\n"},"IERC20.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\ninterface IERC20 {\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Mints `amount` tokens to address `account`.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function mint(address account, uint256 amount) external returns (bool);\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value changes when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * \u003e Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\r\n     * allowance.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"},"PlotXToken.sol":{"content":"/* Copyright (C) 2020 PlotX.io\r\n\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./ERC20.sol\";\r\nimport \"./SafeMath.sol\";\r\n\r\ncontract PlotXToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address =\u003e uint256) public lockedForGV;\r\n\r\n    string public name = \"PLOT\";\r\n    string public symbol = \"PLOT\";\r\n    uint8 public decimals = 18;\r\n    address public operator;\r\n\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operator, \"Not operator\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Initialize PLOT token\r\n     * @param _initialSupply Initial token supply\r\n     * @param _initialTokenHolder Initial token holder address\r\n     */\r\n    constructor(uint256 _initialSupply, address _initialTokenHolder) public {\r\n        _mint(_initialTokenHolder, _initialSupply);\r\n        operator = _initialTokenHolder;\r\n    }\r\n\r\n    /**\r\n     * @dev change operator address\r\n     * @param _newOperator address of new operator\r\n     */\r\n    function changeOperator(address _newOperator)\r\n        public\r\n        onlyOperator\r\n        returns (bool)\r\n    {\r\n        require(_newOperator != address(0), \"New operator cannot be 0 address\");\r\n        operator = _newOperator;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev burns an amount of the tokens of the message sender\r\n     * account.\r\n     * @param amount The amount that will be burnt.\r\n     */\r\n    function burn(uint256 amount) public {\r\n        _burn(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n     * @param from address The address which you want to send tokens from\r\n     * @param value uint256 The amount of token to be burned\r\n     */\r\n    function burnFrom(address from, uint256 value) public {\r\n        _burnFrom(from, value);\r\n    }\r\n\r\n    /**\r\n     * @dev function that mints an amount of the token and assigns it to\r\n     * an account.\r\n     * @param account The account that will receive the created tokens.\r\n     * @param amount The amount that will be created.\r\n     */\r\n    function mint(address account, uint256 amount)\r\n        public\r\n        onlyOperator\r\n        returns (bool)\r\n    {\r\n        _mint(account, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param to The address to transfer to.\r\n     * @param value The amount to be transferred.\r\n     */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        require(lockedForGV[msg.sender] \u003c now, \"Locked for governance\"); // if not voted under governance\r\n        _transfer(msg.sender, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param from address The address which you want to send tokens from\r\n     * @param to address The address which you want to transfer to\r\n     * @param value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    ) public returns (bool) {\r\n        require(lockedForGV[from] \u003c now, \"Locked for governance\"); // if not voted under governance\r\n        _transferFrom(from, to, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Lock the user\u0027s tokens\r\n     * @param _of user\u0027s address.\r\n     */\r\n    function lockForGovernanceVote(address _of, uint256 _period)\r\n        public\r\n        onlyOperator\r\n    {\r\n        if (_period.add(now) \u003e lockedForGV[_of])\r\n            lockedForGV[_of] = _period.add(now);\r\n    }\r\n\r\n    function isLockedForGV(address _of) public view returns (bool) {\r\n        return (lockedForGV[_of] \u003e now);\r\n    }\r\n}\r\n"},"SafeMath.sol":{"content":"pragma solidity ^0.5.0;\r\n\r\n/**\r\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\r\n * checks.\r\n *\r\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\r\n * in bugs, because programmers usually assume that an overflow raises an\r\n * error, which is the standard behavior in high level programming languages.\r\n * `SafeMath` restores this intuition by reverting the transaction when an\r\n * operation overflows.\r\n *\r\n * Using this library instead of the unchecked operations eliminates an entire\r\n * class of bugs, so it\u0027s recommended to use it always.\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n    /**\r\n     * @dev Returns the addition of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `+` operator.\r\n     *\r\n     * Requirements:\r\n     * - Addition cannot overflow.\r\n     */\r\n    function add(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        uint64 c = a + b;\r\n        require(c \u003e= a, \"SafeMath: addition overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     */\r\n    function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b \u003c= a, \"SafeMath: subtraction overflow\");\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n     * overflow (when the result is negative).\r\n     *\r\n     * Counterpart to Solidity\u0027s `-` operator.\r\n     *\r\n     * Requirements:\r\n     * - Subtraction cannot overflow.\r\n     *\r\n     * _Available since v2.4.0._\r\n     */\r\n    function sub(uint64 a, uint64 b, string memory errorMessage) internal pure returns (uint64) {\r\n        require(b \u003c= a, errorMessage);\r\n        uint64 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the multiplication of two unsigned integers, reverting on\r\n     * overflow.\r\n     *\r\n     * Counterpart to Solidity\u0027s `*` operator.\r\n     *\r\n     * Requirements:\r\n     * - Multiplication cannot overflow.\r\n     */\r\n    function mul(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\r\n        // benefit is lost if \u0027b\u0027 is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint64 c = a * b;\r\n        require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the integer division of two unsigned integers. Reverts on\r\n     * division by zero. The result is rounded towards zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\r\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n     * uses an invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b \u003e 0, \"SafeMath: division by zero\");\r\n        uint64 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n     * Reverts when dividing by zero.\r\n     *\r\n     * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\r\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n     * invalid opcode to revert (consuming all remaining gas).\r\n     *\r\n     * Requirements:\r\n     * - The divisor cannot be zero.\r\n     */\r\n    function mod(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        require(b != 0, \"SafeMath: modulo by zero\");\r\n        return a % b;\r\n    }\r\n}\r\n"},"Staking.sol":{"content":"/* Copyright (C) 2020 PlotX.io\r\n  This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n  This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n  You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see http://www.gnu.org/licenses/ */\r\n\r\npragma solidity 0.5.7;\r\n\r\nimport \"./PlotXToken.sol\";\r\nimport \"./SafeMath.sol\";\r\nimport \"./ERC20.sol\";\r\n\r\n\r\ncontract Staking {\r\n    \r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * @dev Structure to store Interest details.\r\n     * It contains total amount of tokens staked and globalYield.\r\n     */\r\n    struct InterestData {\r\n        uint256 globalTotalStaked;\r\n        uint256 globalYieldPerToken; \r\n        uint256 lastUpdated;\r\n        mapping(address =\u003e Staker) stakers;  \r\n    }\r\n\r\n    /**\r\n     * @dev Structure to store staking details.\r\n     * It contains amount of tokens staked and withdrawn interest.\r\n     */\r\n    struct Staker {\r\n        uint256 totalStaked;\r\n        uint256 withdrawnToDate;\r\n        uint256 stakeBuyinRate;  \r\n    }\r\n\r\n\r\n    // Token address\r\n    ERC20 private stakeToken;\r\n\r\n    // Reward token\r\n    PlotXToken private rewardToken;\r\n\r\n    // Interest and staker data\r\n    InterestData public interestData;\r\n\r\n    uint public stakingStartTime;\r\n\r\n    uint public totalReward;\r\n\r\n    // unclaimed reward will be trasfered to this account\r\n    address public vaultAddress; \r\n\r\n    // 10^18\r\n    uint256 private constant DECIMAL1e18 = 10**18;\r\n\r\n    //Total time (in sec) over which reward will be distributed\r\n    uint256 public stakingPeriod;\r\n\r\n    /**\r\n     * @dev Emitted when `staker` stake `value` tokens.\r\n     */\r\n    event Staked(address indexed staker, uint256 value, uint256 _globalYieldPerToken);\r\n\r\n    /**\r\n     * @dev Emitted when `staker` withdraws their stake `value` tokens.\r\n     */\r\n    event StakeWithdrawn(address indexed staker, uint256 value, uint256 _globalYieldPerToken);\r\n\r\n\r\n    /**\r\n     * @dev Emitted when `staker` collects interest `_value`.\r\n     */\r\n    event InterestCollected(\r\n        address indexed staker,\r\n        uint256 _value,\r\n        uint256 _globalYieldPerToken\r\n    );\r\n\r\n    /**     \r\n     * @dev Constructor     \r\n     * @param _stakeToken The address of stake Token       \r\n     * @param _rewardToken The address of reward Token   \r\n     * @param _stakingPeriod valid staking time after staking starts\r\n     * @param _totalRewardToBeDistributed total amount to be distributed as reward\r\n     */\r\n    constructor(\r\n        address _stakeToken,\r\n        address _rewardToken,\r\n        uint256 _stakingPeriod,\r\n        uint256 _totalRewardToBeDistributed,\r\n        uint256 _stakingStart,\r\n        address _vaultAdd\r\n    ) public {\r\n        require(_stakingPeriod \u003e 0, \"Should be positive\");\r\n        require(_totalRewardToBeDistributed \u003e 0, \"Total reward can not be 0\");\r\n        require(_stakingStart \u003e= now, \"Can not be past time\");\r\n        require(_stakeToken != address(0), \"Can not be null address\");\r\n        require(_rewardToken != address(0), \"Can not be null address\");\r\n        require(_vaultAdd != address(0), \"Can not be null address\");\r\n        stakeToken = ERC20(_stakeToken);\r\n        rewardToken = PlotXToken(_rewardToken);\r\n        stakingStartTime = _stakingStart;\r\n        interestData.lastUpdated = _stakingStart;\r\n        stakingPeriod = _stakingPeriod;\r\n        totalReward = _totalRewardToBeDistributed;\r\n        vaultAddress = _vaultAdd;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows a staker to deposit Tokens. Notice that `approve` is\r\n     * needed to be executed before the execution of this method.\r\n     * @param _amount The amount of tokens to stake\r\n     */\r\n    function stake(uint256 _amount) external {\r\n        require(_amount \u003e 0, \"You need to stake a positive token amount\");\r\n        require(\r\n            stakeToken.transferFrom(msg.sender, address(this), _amount),\r\n            \"TransferFrom failed, make sure you approved token transfer\"\r\n        );\r\n        require(now.sub(stakingStartTime) \u003c= stakingPeriod, \"Can not stake after staking period passed\");\r\n        uint newlyInterestGenerated = now.sub(interestData.lastUpdated).mul(totalReward).div(stakingPeriod);\r\n        interestData.lastUpdated = now;\r\n        updateGlobalYieldPerToken(newlyInterestGenerated);\r\n        updateStakeData(msg.sender, _amount);\r\n        emit Staked(msg.sender, _amount, interestData.globalYieldPerToken);\r\n    }\r\n\r\n    /**\r\n     * @dev Updates InterestData and Staker data while staking.\r\n     * must call update globalYieldPerToken before this operation\r\n     * @param _staker                 Staker\u0027s address\r\n     * @param _stake                  Amount of stake\r\n     *\r\n     */\r\n    function updateStakeData(\r\n        address _staker,\r\n        uint256 _stake\r\n    ) internal {\r\n        Staker storage _stakerData = interestData.stakers[_staker];\r\n\r\n        _stakerData.totalStaked = _stakerData.totalStaked.add(_stake);\r\n\r\n        updateStakeBuyinRate(\r\n            _stakerData,\r\n            interestData.globalYieldPerToken,\r\n            _stake\r\n        );\r\n\r\n        interestData.globalTotalStaked = interestData.globalTotalStaked.add(_stake);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates and updates the yield rate in which the staker has entered\r\n     * a staker may stake multiple times, so we calculate his cumulative rate his earning will be calculated based on GlobalYield and StakeBuyinRate\r\n     * Formula:\r\n     * StakeBuyinRate = [StakeBuyinRate(P) + (GlobalYield(P) x Stake)]\r\n     *\r\n     * @param _stakerData                  Staker\u0027s Data\r\n     * @param _globalYieldPerToken         Total yielding amount per token \r\n     * @param _stake                       Amount staked \r\n     *\r\n     */\r\n    function updateStakeBuyinRate(\r\n        Staker storage _stakerData,\r\n        uint256 _globalYieldPerToken,\r\n        uint256 _stake\r\n    ) internal {\r\n\r\n        _stakerData.stakeBuyinRate = _stakerData.stakeBuyinRate.add(\r\n            _globalYieldPerToken.mul(_stake).div(DECIMAL1e18)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws the sender staked Token.\r\n     */\r\n    function withdrawStakeAndInterest(uint256 _amount) external {\r\n        Staker storage staker = interestData.stakers[msg.sender];\r\n        require(_amount \u003e 0, \"Should withdraw positive amount\");\r\n        require(staker.totalStaked \u003e= _amount, \"Not enough token staked\");\r\n        withdrawInterest();\r\n        updateStakeAndInterestData(msg.sender, _amount);\r\n        require(stakeToken.transfer(msg.sender, _amount), \"withdraw transfer failed\");\r\n        emit StakeWithdrawn(msg.sender, _amount, interestData.globalYieldPerToken);\r\n    }\r\n    \r\n    /**\r\n     * @dev Updates InterestData and Staker data while withdrawing stake.\r\n     *\r\n     * @param _staker                 Staker address\r\n     * @param _amount                 Amount of stake to withdraw\r\n     *\r\n     */    \r\n    function updateStakeAndInterestData(\r\n        address _staker,\r\n        uint256 _amount\r\n    ) internal {\r\n        Staker storage _stakerData = interestData.stakers[_staker];\r\n\r\n        _stakerData.totalStaked = _stakerData.totalStaked.sub(_amount);\r\n\r\n        interestData.globalTotalStaked = interestData.globalTotalStaked.sub(_amount);\r\n\r\n        _stakerData.stakeBuyinRate = 0;\r\n        _stakerData.withdrawnToDate = 0;\r\n        updateStakeBuyinRate(\r\n            _stakerData,\r\n            interestData.globalYieldPerToken,\r\n            _stakerData.totalStaked\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraws the sender Earned interest.\r\n     */\r\n    function withdrawInterest() public {\r\n        uint timeSinceLastUpdate = _timeSinceLastUpdate();\r\n        uint newlyInterestGenerated = timeSinceLastUpdate.mul(totalReward).div(stakingPeriod);\r\n        \r\n        updateGlobalYieldPerToken(newlyInterestGenerated);\r\n        uint256 interest = calculateInterest(msg.sender);\r\n        Staker storage stakerData = interestData.stakers[msg.sender];\r\n        stakerData.withdrawnToDate = stakerData.withdrawnToDate.add(interest);\r\n        require(rewardToken.transfer(msg.sender, interest), \"Withdraw interest transfer failed\");\r\n        emit InterestCollected(msg.sender, interest, interestData.globalYieldPerToken);\r\n    }\r\n\r\n    function updateGlobalYield() public {\r\n        uint timeSinceLastUpdate = _timeSinceLastUpdate();\r\n        uint newlyInterestGenerated = timeSinceLastUpdate.mul(totalReward).div(stakingPeriod);\r\n        updateGlobalYieldPerToken(newlyInterestGenerated);\r\n    }\r\n\r\n    function getYieldData(address _staker) public view returns(uint256, uint256)\r\n    {\r\n\r\n      return (interestData.globalYieldPerToken, interestData.stakers[_staker].stakeBuyinRate);\r\n    }\r\n\r\n    function _timeSinceLastUpdate() internal returns(uint256) {\r\n        uint timeSinceLastUpdate;\r\n        if(now.sub(stakingStartTime) \u003e stakingPeriod)\r\n        {\r\n            timeSinceLastUpdate = stakingStartTime.add(stakingPeriod).sub(interestData.lastUpdated);\r\n            interestData.lastUpdated = stakingStartTime.add(stakingPeriod);\r\n        } else {\r\n            timeSinceLastUpdate = now.sub(interestData.lastUpdated);\r\n            interestData.lastUpdated = now;\r\n        }\r\n        return timeSinceLastUpdate;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates Interest for staker for their stake.\r\n     *\r\n     * Formula:\r\n     * EarnedInterest = MAX[TotalStaked x GlobalYield - (StakeBuyinRate + WithdrawnToDate), 0]\r\n     *\r\n     * @param _staker                     Staker\u0027s address\r\n     *\r\n     * @return The amount of tokens credit for the staker.\r\n     */\r\n    function calculateInterest(address _staker)\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Staker storage stakerData = interestData.stakers[_staker];\r\n\r\n        \r\n        uint256 _withdrawnToDate = stakerData.withdrawnToDate;\r\n\r\n        uint256 intermediateInterest = stakerData\r\n            .totalStaked\r\n            .mul(interestData.globalYieldPerToken).div(DECIMAL1e18);\r\n\r\n        uint256 intermediateVal = _withdrawnToDate.add(\r\n            stakerData.stakeBuyinRate\r\n        );\r\n\r\n        // will lead to -ve value\r\n        if (intermediateVal \u003e intermediateInterest) {\r\n            return 0;\r\n        }\r\n\r\n        uint _earnedInterest = (intermediateInterest.sub(intermediateVal));\r\n\r\n        return _earnedInterest;\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates and updates new accrued amount per token since last update.\r\n     *\r\n     * Formula:\r\n     * GlobalYield = GlobalYield(P) + newlyGeneratedInterest/GlobalTotalStake.\r\n     *\r\n     * @param _interestGenerated  Interest token earned since last update.\r\n     *\r\n     */\r\n    function updateGlobalYieldPerToken(\r\n        uint256 _interestGenerated\r\n    ) internal {\r\n        if (interestData.globalTotalStaked == 0) {\r\n            require(rewardToken.transfer(vaultAddress, _interestGenerated), \"Transfer failed while trasfering to vault\");\r\n            return;\r\n        }\r\n        interestData.globalYieldPerToken = interestData.globalYieldPerToken.add(\r\n            _interestGenerated\r\n                .mul(DECIMAL1e18) \r\n                .div(interestData.globalTotalStaked) \r\n        );\r\n    }\r\n\r\n\r\n    function getStakerData(address _staker) public view returns(uint256, uint256)\r\n    {\r\n\r\n      return (interestData.stakers[_staker].totalStaked, interestData.stakers[_staker].withdrawnToDate);\r\n    }\r\n\r\n    /**\r\n     * @dev returns stats data.\r\n     * @param _staker Address of staker.\r\n     * @return Total staked.\r\n     * @return Total reward to be distributed.\r\n     * @return estimated reward for user at end of staking period if no one stakes from current time.\r\n     * @return Unlocked reward based on elapsed time.\r\n     * @return Accrued reward for user till now.\r\n     */\r\n    function getStatsData(address _staker) external view returns(uint, uint, uint, uint, uint)\r\n    {\r\n\r\n        Staker storage stakerData = interestData.stakers[_staker];\r\n        uint estimatedReward = 0;\r\n        uint unlockedReward = 0;\r\n        uint accruedReward = 0;\r\n        uint timeElapsed = now.sub(stakingStartTime);\r\n\r\n        if(timeElapsed \u003e stakingPeriod)\r\n        {\r\n            timeElapsed = stakingPeriod;\r\n        }\r\n\r\n        unlockedReward = timeElapsed.mul(totalReward).div(stakingPeriod);\r\n\r\n        uint timeSinceLastUpdate;\r\n        if(timeElapsed == stakingPeriod)\r\n        {\r\n            timeSinceLastUpdate = stakingStartTime.add(stakingPeriod).sub(interestData.lastUpdated);\r\n        } else {\r\n            timeSinceLastUpdate = now.sub(interestData.lastUpdated);\r\n        }\r\n        uint newlyInterestGenerated = timeSinceLastUpdate.mul(totalReward).div(stakingPeriod);\r\n        uint updatedGlobalYield;\r\n        uint stakingTimeLeft = 0;\r\n        if(now \u003c stakingStartTime.add(stakingPeriod)){\r\n         stakingTimeLeft = stakingStartTime.add(stakingPeriod).sub(now);\r\n        }\r\n        uint interestGeneratedEnd = stakingTimeLeft.mul(totalReward).div(stakingPeriod);\r\n        uint globalYieldEnd;\r\n        if (interestData.globalTotalStaked != 0) {\r\n            updatedGlobalYield = interestData.globalYieldPerToken.add(\r\n            newlyInterestGenerated\r\n                .mul(DECIMAL1e18)\r\n                .div(interestData.globalTotalStaked));\r\n\r\n            globalYieldEnd = updatedGlobalYield.add(interestGeneratedEnd.mul(DECIMAL1e18).div(interestData.globalTotalStaked));\r\n        }\r\n        \r\n        accruedReward = stakerData\r\n            .totalStaked\r\n            .mul(updatedGlobalYield).div(DECIMAL1e18);\r\n\r\n        if (stakerData.withdrawnToDate.add(stakerData.stakeBuyinRate) \u003e accruedReward)\r\n        {\r\n            accruedReward = 0;\r\n        } else {\r\n\r\n            accruedReward = accruedReward.sub(stakerData.withdrawnToDate.add(stakerData.stakeBuyinRate));\r\n        }\r\n\r\n        estimatedReward = stakerData\r\n            .totalStaked\r\n            .mul(globalYieldEnd).div(DECIMAL1e18);\r\n        if (stakerData.withdrawnToDate.add(stakerData.stakeBuyinRate) \u003e estimatedReward) {\r\n            estimatedReward = 0;\r\n        } else {\r\n\r\n            estimatedReward = estimatedReward.sub(stakerData.withdrawnToDate.add(stakerData.stakeBuyinRate));\r\n        }\r\n\r\n        return (interestData.globalTotalStaked, totalReward, estimatedReward, unlockedReward, accruedReward);\r\n\r\n    }\r\n}\r\n"}}