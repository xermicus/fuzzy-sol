{"DefaultReserveInterestRateStrategy.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {SafeMath} from \u0027./SafeMath.sol\u0027;\nimport {IReserveInterestRateStrategy} from \u0027./IReserveInterestRateStrategy.sol\u0027;\nimport {WadRayMath} from \u0027./WadRayMath.sol\u0027;\nimport {PercentageMath} from \u0027./PercentageMath.sol\u0027;\nimport {ILendingPoolAddressesProvider} from \u0027./ILendingPoolAddressesProvider.sol\u0027;\nimport {ILendingRateOracle} from \u0027./ILendingRateOracle.sol\u0027;\n\n/**\n * @title DefaultReserveInterestRateStrategy contract\n * @notice Implements the calculation of the interest rates depending on the reserve state\n * @dev The model of interest rate is based on 2 slopes, one before the `OPTIMAL_UTILIZATION_RATE`\n * point of utilization and another from that one to 100%\n * - An instance of this same contract, can\u0027t be used across different Aave markets, due to the caching\n *   of the LendingPoolAddressesProvider\n * @author Aave\n **/\ncontract DefaultReserveInterestRateStrategy is IReserveInterestRateStrategy {\n  using WadRayMath for uint256;\n  using SafeMath for uint256;\n  using PercentageMath for uint256;\n\n  /**\n   * @dev this constant represents the utilization rate at which the pool aims to obtain most competitive borrow rates.\n   * Expressed in ray\n   **/\n  uint256 public immutable OPTIMAL_UTILIZATION_RATE;\n\n  /**\n   * @dev This constant represents the excess utilization rate above the optimal. It\u0027s always equal to\n   * 1-optimal utilization rate. Added as a constant here for gas optimizations.\n   * Expressed in ray\n   **/\n\n  uint256 public immutable EXCESS_UTILIZATION_RATE;\n\n  ILendingPoolAddressesProvider public immutable addressesProvider;\n\n  // Base variable borrow rate when Utilization rate = 0. Expressed in ray\n  uint256 internal immutable _baseVariableBorrowRate;\n\n  // Slope of the variable interest curve when utilization rate \u003e 0 and \u003c= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n  uint256 internal immutable _variableRateSlope1;\n\n  // Slope of the variable interest curve when utilization rate \u003e OPTIMAL_UTILIZATION_RATE. Expressed in ray\n  uint256 internal immutable _variableRateSlope2;\n\n  // Slope of the stable interest curve when utilization rate \u003e 0 and \u003c= OPTIMAL_UTILIZATION_RATE. Expressed in ray\n  uint256 internal immutable _stableRateSlope1;\n\n  // Slope of the stable interest curve when utilization rate \u003e OPTIMAL_UTILIZATION_RATE. Expressed in ray\n  uint256 internal immutable _stableRateSlope2;\n\n  constructor(\n    ILendingPoolAddressesProvider provider,\n    uint256 optimalUtilizationRate,\n    uint256 baseVariableBorrowRate,\n    uint256 variableRateSlope1,\n    uint256 variableRateSlope2,\n    uint256 stableRateSlope1,\n    uint256 stableRateSlope2\n  ) public {\n    OPTIMAL_UTILIZATION_RATE = optimalUtilizationRate;\n    EXCESS_UTILIZATION_RATE = WadRayMath.ray().sub(optimalUtilizationRate);\n    addressesProvider = provider;\n    _baseVariableBorrowRate = baseVariableBorrowRate;\n    _variableRateSlope1 = variableRateSlope1;\n    _variableRateSlope2 = variableRateSlope2;\n    _stableRateSlope1 = stableRateSlope1;\n    _stableRateSlope2 = stableRateSlope2;\n  }\n\n  function variableRateSlope1() external view returns (uint256) {\n    return _variableRateSlope1;\n  }\n\n  function variableRateSlope2() external view returns (uint256) {\n    return _variableRateSlope2;\n  }\n\n  function stableRateSlope1() external view returns (uint256) {\n    return _stableRateSlope1;\n  }\n\n  function stableRateSlope2() external view returns (uint256) {\n    return _stableRateSlope2;\n  }\n\n  function baseVariableBorrowRate() external view override returns (uint256) {\n    return _baseVariableBorrowRate;\n  }\n\n  function getMaxVariableBorrowRate() external view override returns (uint256) {\n    return _baseVariableBorrowRate.add(_variableRateSlope1).add(_variableRateSlope2);\n  }\n\n  struct CalcInterestRatesLocalVars {\n    uint256 totalDebt;\n    uint256 currentVariableBorrowRate;\n    uint256 currentStableBorrowRate;\n    uint256 currentLiquidityRate;\n    uint256 utilizationRate;\n  }\n\n  /**\n   * @dev Calculates the interest rates depending on the reserve\u0027s state and configurations\n   * @param reserve The address of the reserve\n   * @param availableLiquidity The liquidity available in the reserve\n   * @param totalStableDebt The total borrowed from the reserve a stable rate\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n   * @param averageStableBorrowRate The weighted average of all the stable rate loans\n   * @param reserveFactor The reserve portion of the interest that goes to the treasury of the market\n   * @return The liquidity rate, the stable borrow rate and the variable borrow rate\n   **/\n  function calculateInterestRates(\n    address reserve,\n    uint256 availableLiquidity,\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 averageStableBorrowRate,\n    uint256 reserveFactor\n  )\n    external\n    view\n    override\n    returns (\n      uint256,\n      uint256,\n      uint256\n    )\n  {\n    CalcInterestRatesLocalVars memory vars;\n\n    vars.totalDebt = totalStableDebt.add(totalVariableDebt);\n    vars.currentVariableBorrowRate = 0;\n    vars.currentStableBorrowRate = 0;\n    vars.currentLiquidityRate = 0;\n\n    uint256 utilizationRate =\n      vars.totalDebt == 0 ? 0 : vars.totalDebt.rayDiv(availableLiquidity.add(vars.totalDebt));\n\n    vars.currentStableBorrowRate = ILendingRateOracle(addressesProvider.getLendingRateOracle())\n      .getMarketBorrowRate(reserve);\n\n    if (utilizationRate \u003e OPTIMAL_UTILIZATION_RATE) {\n      uint256 excessUtilizationRateRatio =\n        utilizationRate.sub(OPTIMAL_UTILIZATION_RATE).rayDiv(EXCESS_UTILIZATION_RATE);\n\n      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(_stableRateSlope1).add(\n        _stableRateSlope2.rayMul(excessUtilizationRateRatio)\n      );\n\n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(_variableRateSlope1).add(\n        _variableRateSlope2.rayMul(excessUtilizationRateRatio)\n      );\n    } else {\n      vars.currentStableBorrowRate = vars.currentStableBorrowRate.add(\n        _stableRateSlope1.rayMul(utilizationRate.rayDiv(OPTIMAL_UTILIZATION_RATE))\n      );\n      vars.currentVariableBorrowRate = _baseVariableBorrowRate.add(\n        utilizationRate.rayMul(_variableRateSlope1).rayDiv(OPTIMAL_UTILIZATION_RATE)\n      );\n    }\n\n    vars.currentLiquidityRate = _getOverallBorrowRate(\n      totalStableDebt,\n      totalVariableDebt,\n      vars\n        .currentVariableBorrowRate,\n      averageStableBorrowRate\n    )\n      .rayMul(utilizationRate)\n      .percentMul(PercentageMath.PERCENTAGE_FACTOR.sub(reserveFactor));\n\n    return (\n      vars.currentLiquidityRate,\n      vars.currentStableBorrowRate,\n      vars.currentVariableBorrowRate\n    );\n  }\n\n  /**\n   * @dev Calculates the overall borrow rate as the weighted average between the total variable debt and total stable debt\n   * @param totalStableDebt The total borrowed from the reserve a stable rate\n   * @param totalVariableDebt The total borrowed from the reserve at a variable rate\n   * @param currentVariableBorrowRate The current variable borrow rate of the reserve\n   * @param currentAverageStableBorrowRate The current weighted average of all the stable rate loans\n   * @return The weighted averaged borrow rate\n   **/\n  function _getOverallBorrowRate(\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 currentVariableBorrowRate,\n    uint256 currentAverageStableBorrowRate\n  ) internal pure returns (uint256) {\n    uint256 totalDebt = totalStableDebt.add(totalVariableDebt);\n\n    if (totalDebt == 0) return 0;\n\n    uint256 weightedVariableRate = totalVariableDebt.wadToRay().rayMul(currentVariableBorrowRate);\n\n    uint256 weightedStableRate = totalStableDebt.wadToRay().rayMul(currentAverageStableBorrowRate);\n\n    uint256 overallBorrowRate =\n      weightedVariableRate.add(weightedStableRate).rayDiv(totalDebt.wadToRay());\n\n    return overallBorrowRate;\n  }\n}"},"Errors.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @title Errors library\n * @author Aave\n * @notice Defines the error messages emitted by the different contracts of the Aave protocol\n * @dev Error messages prefix glossary:\n *  - VL = ValidationLogic\n *  - MATH = Math libraries\n *  - CT = Common errors between tokens (AToken, VariableDebtToken and StableDebtToken)\n *  - AT = AToken\n *  - SDT = StableDebtToken\n *  - VDT = VariableDebtToken\n *  - LP = LendingPool\n *  - LPAPR = LendingPoolAddressesProviderRegistry\n *  - LPC = LendingPoolConfiguration\n *  - RL = ReserveLogic\n *  - LPCM = LendingPoolCollateralManager\n *  - P = Pausable\n */\nlibrary Errors {\n  //common errors\n  string public constant CALLER_NOT_POOL_ADMIN = \u002733\u0027; // \u0027The caller must be the pool admin\u0027\n  string public constant BORROW_ALLOWANCE_NOT_ENOUGH = \u002759\u0027; // User borrows on behalf, but allowance are too small\n\n  //contract specific errors\n  string public constant VL_INVALID_AMOUNT = \u00271\u0027; // \u0027Amount must be greater than 0\u0027\n  string public constant VL_NO_ACTIVE_RESERVE = \u00272\u0027; // \u0027Action requires an active reserve\u0027\n  string public constant VL_RESERVE_FROZEN = \u00273\u0027; // \u0027Action cannot be performed because the reserve is frozen\u0027\n  string public constant VL_CURRENT_AVAILABLE_LIQUIDITY_NOT_ENOUGH = \u00274\u0027; // \u0027The current liquidity is not enough\u0027\n  string public constant VL_NOT_ENOUGH_AVAILABLE_USER_BALANCE = \u00275\u0027; // \u0027User cannot withdraw more than the available balance\u0027\n  string public constant VL_TRANSFER_NOT_ALLOWED = \u00276\u0027; // \u0027Transfer cannot be allowed.\u0027\n  string public constant VL_BORROWING_NOT_ENABLED = \u00277\u0027; // \u0027Borrowing is not enabled\u0027\n  string public constant VL_INVALID_INTEREST_RATE_MODE_SELECTED = \u00278\u0027; // \u0027Invalid interest rate mode selected\u0027\n  string public constant VL_COLLATERAL_BALANCE_IS_0 = \u00279\u0027; // \u0027The collateral balance is 0\u0027\n  string public constant VL_HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = \u002710\u0027; // \u0027Health factor is lesser than the liquidation threshold\u0027\n  string public constant VL_COLLATERAL_CANNOT_COVER_NEW_BORROW = \u002711\u0027; // \u0027There is not enough collateral to cover a new borrow\u0027\n  string public constant VL_STABLE_BORROWING_NOT_ENABLED = \u002712\u0027; // stable borrowing not enabled\n  string public constant VL_COLLATERAL_SAME_AS_BORROWING_CURRENCY = \u002713\u0027; // collateral is (mostly) the same currency that is being borrowed\n  string public constant VL_AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = \u002714\u0027; // \u0027The requested amount is greater than the max loan size in stable rate mode\n  string public constant VL_NO_DEBT_OF_SELECTED_TYPE = \u002715\u0027; // \u0027for repayment of stable debt, the user needs to have stable debt, otherwise, he needs to have variable debt\u0027\n  string public constant VL_NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = \u002716\u0027; // \u0027To repay on behalf of an user an explicit amount to repay is needed\u0027\n  string public constant VL_NO_STABLE_RATE_LOAN_IN_RESERVE = \u002717\u0027; // \u0027User does not have a stable rate loan in progress on this reserve\u0027\n  string public constant VL_NO_VARIABLE_RATE_LOAN_IN_RESERVE = \u002718\u0027; // \u0027User does not have a variable rate loan in progress on this reserve\u0027\n  string public constant VL_UNDERLYING_BALANCE_NOT_GREATER_THAN_0 = \u002719\u0027; // \u0027The underlying balance needs to be greater than 0\u0027\n  string public constant VL_DEPOSIT_ALREADY_IN_USE = \u002720\u0027; // \u0027User deposit is already being used as collateral\u0027\n  string public constant LP_NOT_ENOUGH_STABLE_BORROW_BALANCE = \u002721\u0027; // \u0027User does not have any stable rate loan for this reserve\u0027\n  string public constant LP_INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = \u002722\u0027; // \u0027Interest rate rebalance conditions were not met\u0027\n  string public constant LP_LIQUIDATION_CALL_FAILED = \u002723\u0027; // \u0027Liquidation call failed\u0027\n  string public constant LP_NOT_ENOUGH_LIQUIDITY_TO_BORROW = \u002724\u0027; // \u0027There is not enough liquidity available to borrow\u0027\n  string public constant LP_REQUESTED_AMOUNT_TOO_SMALL = \u002725\u0027; // \u0027The requested amount is too small for a FlashLoan.\u0027\n  string public constant LP_INCONSISTENT_PROTOCOL_ACTUAL_BALANCE = \u002726\u0027; // \u0027The actual balance of the protocol is inconsistent\u0027\n  string public constant LP_CALLER_NOT_LENDING_POOL_CONFIGURATOR = \u002727\u0027; // \u0027The caller of the function is not the lending pool configurator\u0027\n  string public constant LP_INCONSISTENT_FLASHLOAN_PARAMS = \u002728\u0027;\n  string public constant CT_CALLER_MUST_BE_LENDING_POOL = \u002729\u0027; // \u0027The caller of this function must be a lending pool\u0027\n  string public constant CT_CANNOT_GIVE_ALLOWANCE_TO_HIMSELF = \u002730\u0027; // \u0027User cannot give allowance to himself\u0027\n  string public constant CT_TRANSFER_AMOUNT_NOT_GT_0 = \u002731\u0027; // \u0027Transferred amount needs to be greater than zero\u0027\n  string public constant RL_RESERVE_ALREADY_INITIALIZED = \u002732\u0027; // \u0027Reserve has already been initialized\u0027\n  string public constant LPC_RESERVE_LIQUIDITY_NOT_0 = \u002734\u0027; // \u0027The liquidity of the reserve needs to be 0\u0027\n  string public constant LPC_INVALID_ATOKEN_POOL_ADDRESS = \u002735\u0027; // \u0027The liquidity of the reserve needs to be 0\u0027\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_POOL_ADDRESS = \u002736\u0027; // \u0027The liquidity of the reserve needs to be 0\u0027\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_POOL_ADDRESS = \u002737\u0027; // \u0027The liquidity of the reserve needs to be 0\u0027\n  string public constant LPC_INVALID_STABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = \u002738\u0027; // \u0027The liquidity of the reserve needs to be 0\u0027\n  string public constant LPC_INVALID_VARIABLE_DEBT_TOKEN_UNDERLYING_ADDRESS = \u002739\u0027; // \u0027The liquidity of the reserve needs to be 0\u0027\n  string public constant LPC_INVALID_ADDRESSES_PROVIDER_ID = \u002740\u0027; // \u0027The liquidity of the reserve needs to be 0\u0027\n  string public constant LPC_INVALID_CONFIGURATION = \u002775\u0027; // \u0027Invalid risk parameters for the reserve\u0027\n  string public constant LPC_CALLER_NOT_EMERGENCY_ADMIN = \u002776\u0027; // \u0027The caller must be the emergency admin\u0027\n  string public constant LPAPR_PROVIDER_NOT_REGISTERED = \u002741\u0027; // \u0027Provider is not registered\u0027\n  string public constant LPCM_HEALTH_FACTOR_NOT_BELOW_THRESHOLD = \u002742\u0027; // \u0027Health factor is not below the threshold\u0027\n  string public constant LPCM_COLLATERAL_CANNOT_BE_LIQUIDATED = \u002743\u0027; // \u0027The collateral chosen cannot be liquidated\u0027\n  string public constant LPCM_SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = \u002744\u0027; // \u0027User did not borrow the specified currency\u0027\n  string public constant LPCM_NOT_ENOUGH_LIQUIDITY_TO_LIQUIDATE = \u002745\u0027; // \"There isn\u0027t enough liquidity available to liquidate\"\n  string public constant LPCM_NO_ERRORS = \u002746\u0027; // \u0027No errors\u0027\n  string public constant LP_INVALID_FLASHLOAN_MODE = \u002747\u0027; //Invalid flashloan mode selected\n  string public constant MATH_MULTIPLICATION_OVERFLOW = \u002748\u0027;\n  string public constant MATH_ADDITION_OVERFLOW = \u002749\u0027;\n  string public constant MATH_DIVISION_BY_ZERO = \u002750\u0027;\n  string public constant RL_LIQUIDITY_INDEX_OVERFLOW = \u002751\u0027; //  Liquidity index overflows uint128\n  string public constant RL_VARIABLE_BORROW_INDEX_OVERFLOW = \u002752\u0027; //  Variable borrow index overflows uint128\n  string public constant RL_LIQUIDITY_RATE_OVERFLOW = \u002753\u0027; //  Liquidity rate overflows uint128\n  string public constant RL_VARIABLE_BORROW_RATE_OVERFLOW = \u002754\u0027; //  Variable borrow rate overflows uint128\n  string public constant RL_STABLE_BORROW_RATE_OVERFLOW = \u002755\u0027; //  Stable borrow rate overflows uint128\n  string public constant CT_INVALID_MINT_AMOUNT = \u002756\u0027; //invalid amount to mint\n  string public constant LP_FAILED_REPAY_WITH_COLLATERAL = \u002757\u0027;\n  string public constant CT_INVALID_BURN_AMOUNT = \u002758\u0027; //invalid amount to burn\n  string public constant LP_FAILED_COLLATERAL_SWAP = \u002760\u0027;\n  string public constant LP_INVALID_EQUAL_ASSETS_TO_SWAP = \u002761\u0027;\n  string public constant LP_REENTRANCY_NOT_ALLOWED = \u002762\u0027;\n  string public constant LP_CALLER_MUST_BE_AN_ATOKEN = \u002763\u0027;\n  string public constant LP_IS_PAUSED = \u002764\u0027; // \u0027Pool is paused\u0027\n  string public constant LP_NO_MORE_RESERVES_ALLOWED = \u002765\u0027;\n  string public constant LP_INVALID_FLASH_LOAN_EXECUTOR_RETURN = \u002766\u0027;\n  string public constant RC_INVALID_LTV = \u002767\u0027;\n  string public constant RC_INVALID_LIQ_THRESHOLD = \u002768\u0027;\n  string public constant RC_INVALID_LIQ_BONUS = \u002769\u0027;\n  string public constant RC_INVALID_DECIMALS = \u002770\u0027;\n  string public constant RC_INVALID_RESERVE_FACTOR = \u002771\u0027;\n  string public constant LPAPR_INVALID_ADDRESSES_PROVIDER_ID = \u002772\u0027;\n  string public constant VL_INCONSISTENT_FLASHLOAN_PARAMS = \u002773\u0027;\n  string public constant LP_INCONSISTENT_PARAMS_LENGTH = \u002774\u0027;\n  string public constant UL_INVALID_INDEX = \u002777\u0027;\n  string public constant LP_NOT_CONTRACT = \u002778\u0027;\n  string public constant SDT_STABLE_DEBT_OVERFLOW = \u002779\u0027;\n  string public constant SDT_BURN_EXCEEDS_BALANCE = \u002780\u0027;\n\n  enum CollateralManagerErrors {\n    NO_ERROR,\n    NO_COLLATERAL_AVAILABLE,\n    COLLATERAL_CANNOT_BE_LIQUIDATED,\n    CURRRENCY_NOT_BORROWED,\n    HEALTH_FACTOR_ABOVE_THRESHOLD,\n    NOT_ENOUGH_LIQUIDITY,\n    NO_ACTIVE_RESERVE,\n    HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD,\n    INVALID_EQUAL_ASSETS_TO_SWAP,\n    FROZEN_RESERVE\n  }\n}"},"ILendingPoolAddressesProvider.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @title LendingPoolAddressesProvider contract\n * @dev Main registry of addresses part of or connected to the protocol, including permissioned roles\n * - Acting also as factory of proxies and admin of those, so with right to change its implementations\n * - Owned by the Aave Governance\n * @author Aave\n **/\ninterface ILendingPoolAddressesProvider {\n  event MarketIdSet(string newMarketId);\n  event LendingPoolUpdated(address indexed newAddress);\n  event ConfigurationAdminUpdated(address indexed newAddress);\n  event EmergencyAdminUpdated(address indexed newAddress);\n  event LendingPoolConfiguratorUpdated(address indexed newAddress);\n  event LendingPoolCollateralManagerUpdated(address indexed newAddress);\n  event PriceOracleUpdated(address indexed newAddress);\n  event LendingRateOracleUpdated(address indexed newAddress);\n  event ProxyCreated(bytes32 id, address indexed newAddress);\n  event AddressSet(bytes32 id, address indexed newAddress, bool hasProxy);\n\n  function getMarketId() external view returns (string memory);\n\n  function setMarketId(string calldata marketId) external;\n\n  function setAddress(bytes32 id, address newAddress) external;\n\n  function setAddressAsProxy(bytes32 id, address impl) external;\n\n  function getAddress(bytes32 id) external view returns (address);\n\n  function getLendingPool() external view returns (address);\n\n  function setLendingPoolImpl(address pool) external;\n\n  function getLendingPoolConfigurator() external view returns (address);\n\n  function setLendingPoolConfiguratorImpl(address configurator) external;\n\n  function getLendingPoolCollateralManager() external view returns (address);\n\n  function setLendingPoolCollateralManager(address manager) external;\n\n  function getPoolAdmin() external view returns (address);\n\n  function setPoolAdmin(address admin) external;\n\n  function getEmergencyAdmin() external view returns (address);\n\n  function setEmergencyAdmin(address admin) external;\n\n  function getPriceOracle() external view returns (address);\n\n  function setPriceOracle(address priceOracle) external;\n\n  function getLendingRateOracle() external view returns (address);\n\n  function setLendingRateOracle(address lendingRateOracle) external;\n}"},"ILendingRateOracle.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @title ILendingRateOracle interface\n * @notice Interface for the Aave borrow rate oracle. Provides the average market borrow rate to be used as a base for the stable borrow rate calculations\n **/\n\ninterface ILendingRateOracle {\n  /**\n    @dev returns the market borrow rate in ray\n    **/\n  function getMarketBorrowRate(address asset) external view returns (uint256);\n\n  /**\n    @dev sets the market borrow rate. Rate value must be in ray\n    **/\n  function setMarketBorrowRate(address asset, uint256 rate) external;\n}"},"IReserveInterestRateStrategy.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @title IReserveInterestRateStrategyInterface interface\n * @dev Interface for the calculation of the interest rates\n * @author Aave\n */\ninterface IReserveInterestRateStrategy {\n  function baseVariableBorrowRate() external view returns (uint256);\n\n  function getMaxVariableBorrowRate() external view returns (uint256);\n\n  function calculateInterestRates(\n    address reserve,\n    uint256 utilizationRate,\n    uint256 totalStableDebt,\n    uint256 totalVariableDebt,\n    uint256 averageStableBorrowRate,\n    uint256 reserveFactor\n  )\n    external\n    view\n    returns (\n      uint256 liquidityRate,\n      uint256 stableBorrowRate,\n      uint256 variableBorrowRate\n    );\n}"},"PercentageMath.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {Errors} from \u0027./Errors.sol\u0027;\n\n/**\n * @title PercentageMath library\n * @author Aave\n * @notice Provides functions to perform percentage calculations\n * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR\n * @dev Operations are rounded half up\n **/\n\nlibrary PercentageMath {\n  uint256 constant PERCENTAGE_FACTOR = 1e4; //percentage plus two decimals\n  uint256 constant HALF_PERCENT = PERCENTAGE_FACTOR / 2;\n\n  /**\n   * @dev Executes a percentage multiplication\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return The percentage of value\n   **/\n  function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256) {\n    if (value == 0 || percentage == 0) {\n      return 0;\n    }\n\n    require(\n      value \u003c= (type(uint256).max - HALF_PERCENT) / percentage,\n      Errors.MATH_MULTIPLICATION_OVERFLOW\n    );\n\n    return (value * percentage + HALF_PERCENT) / PERCENTAGE_FACTOR;\n  }\n\n  /**\n   * @dev Executes a percentage division\n   * @param value The value of which the percentage needs to be calculated\n   * @param percentage The percentage of the value to be calculated\n   * @return The value divided the percentage\n   **/\n  function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256) {\n    require(percentage != 0, Errors.MATH_DIVISION_BY_ZERO);\n    uint256 halfPercentage = percentage / 2;\n\n    require(\n      value \u003c= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR,\n      Errors.MATH_MULTIPLICATION_OVERFLOW\n    );\n\n    return (value * PERCENTAGE_FACTOR + halfPercentage) / percentage;\n  }\n}"},"SafeMath.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\n/**\n * @dev Wrappers over Solidity\u0027s arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it\u0027s recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `+` operator.\n   *\n   * Requirements:\n   * - Addition cannot overflow.\n   */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a, \u0027SafeMath: addition overflow\u0027);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \u0027SafeMath: subtraction overflow\u0027);\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n   * overflow (when the result is negative).\n   *\n   * Counterpart to Solidity\u0027s `-` operator.\n   *\n   * Requirements:\n   * - Subtraction cannot overflow.\n   */\n  function sub(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b \u003c= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on\n   * overflow.\n   *\n   * Counterpart to Solidity\u0027s `*` operator.\n   *\n   * Requirements:\n   * - Multiplication cannot overflow.\n   */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \u0027SafeMath: multiplication overflow\u0027);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \u0027SafeMath: division by zero\u0027);\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n   * division by zero. The result is rounded towards zero.\n   *\n   * Counterpart to Solidity\u0027s `/` operator. Note: this function uses a\n   * `revert` opcode (which leaves remaining gas untouched) while Solidity\n   * uses an invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function div(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b \u003e 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \u0027SafeMath: modulo by zero\u0027);\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n   * Reverts with custom message when dividing by zero.\n   *\n   * Counterpart to Solidity\u0027s `%` operator. This function uses a `revert`\n   * opcode (which leaves remaining gas untouched) while Solidity uses an\n   * invalid opcode to revert (consuming all remaining gas).\n   *\n   * Requirements:\n   * - The divisor cannot be zero.\n   */\n  function mod(\n    uint256 a,\n    uint256 b,\n    string memory errorMessage\n  ) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}"},"WadRayMath.sol":{"content":"// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.6.12;\n\nimport {Errors} from \u0027./Errors.sol\u0027;\n\n/**\n * @title WadRayMath library\n * @author Aave\n * @dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n **/\n\nlibrary WadRayMath {\n  uint256 internal constant WAD = 1e18;\n  uint256 internal constant halfWAD = WAD / 2;\n\n  uint256 internal constant RAY = 1e27;\n  uint256 internal constant halfRAY = RAY / 2;\n\n  uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n  /**\n   * @return One ray, 1e27\n   **/\n  function ray() internal pure returns (uint256) {\n    return RAY;\n  }\n\n  /**\n   * @return One wad, 1e18\n   **/\n\n  function wad() internal pure returns (uint256) {\n    return WAD;\n  }\n\n  /**\n   * @return Half ray, 1e27/2\n   **/\n  function halfRay() internal pure returns (uint256) {\n    return halfRAY;\n  }\n\n  /**\n   * @return Half ray, 1e18/2\n   **/\n  function halfWad() internal pure returns (uint256) {\n    return halfWAD;\n  }\n\n  /**\n   * @dev Multiplies two wad, rounding half up to the nearest wad\n   * @param a Wad\n   * @param b Wad\n   * @return The result of a*b, in wad\n   **/\n  function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n\n    require(a \u003c= (type(uint256).max - halfWAD) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n    return (a * b + halfWAD) / WAD;\n  }\n\n  /**\n   * @dev Divides two wad, rounding half up to the nearest wad\n   * @param a Wad\n   * @param b Wad\n   * @return The result of a/b, in wad\n   **/\n  function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n    uint256 halfB = b / 2;\n\n    require(a \u003c= (type(uint256).max - halfB) / WAD, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n    return (a * WAD + halfB) / b;\n  }\n\n  /**\n   * @dev Multiplies two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a*b, in ray\n   **/\n  function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0 || b == 0) {\n      return 0;\n    }\n\n    require(a \u003c= (type(uint256).max - halfRAY) / b, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n    return (a * b + halfRAY) / RAY;\n  }\n\n  /**\n   * @dev Divides two ray, rounding half up to the nearest ray\n   * @param a Ray\n   * @param b Ray\n   * @return The result of a/b, in ray\n   **/\n  function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, Errors.MATH_DIVISION_BY_ZERO);\n    uint256 halfB = b / 2;\n\n    require(a \u003c= (type(uint256).max - halfB) / RAY, Errors.MATH_MULTIPLICATION_OVERFLOW);\n\n    return (a * RAY + halfB) / b;\n  }\n\n  /**\n   * @dev Casts ray down to wad\n   * @param a Ray\n   * @return a casted to wad, rounded half up to the nearest wad\n   **/\n  function rayToWad(uint256 a) internal pure returns (uint256) {\n    uint256 halfRatio = WAD_RAY_RATIO / 2;\n    uint256 result = halfRatio + a;\n    require(result \u003e= halfRatio, Errors.MATH_ADDITION_OVERFLOW);\n\n    return result / WAD_RAY_RATIO;\n  }\n\n  /**\n   * @dev Converts wad up to ray\n   * @param a Wad\n   * @return a converted in ray\n   **/\n  function wadToRay(uint256 a) internal pure returns (uint256) {\n    uint256 result = a * WAD_RAY_RATIO;\n    require(result / WAD_RAY_RATIO == a, Errors.MATH_MULTIPLICATION_OVERFLOW);\n    return result;\n  }\n}"}}