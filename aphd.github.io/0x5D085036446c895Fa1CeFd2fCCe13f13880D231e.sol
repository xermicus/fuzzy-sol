{{
  "language": "Solidity",
  "settings": {
    "evmVersion": "istanbul",
    "libraries": {},
    "metadata": {
      "bytecodeHash": "ipfs",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "remappings": [],
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "devdoc",
          "userdoc",
          "metadata",
          "abi"
        ]
      }
    }
  },
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is no longer needed starting with Solidity 0.8. The compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "contracts/Presale.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"./interfaces/IVesting.sol\";\nimport './interfaces/IStripToken.sol';\n\ncontract Presale {\n    using SafeMath for uint256;\n\n    address private owner;\n\n    struct PresaleBuyer {\n        uint256 amountDepositedWei; // Funds token amount per recipient.\n        uint256 amountStrip; // Rewards token that needs to be vested.\n    }\n\n    mapping(address => PresaleBuyer) public recipients; // Presale Buyers\n\n    uint256 public constant MAX_ALLOC_STRIP = 2e8 * 1e18; // 200,000,000 STRIP is the max allocation for each presale buyer\n    uint256 public constant MAX_ALLOC_WEI = 505e15; // 0.5 ETH + 1% tax is the max allocation for each presale buyer\n    uint256 public constant IDS = 120e27; // Total StripToken amount for presale : 120b\n    \n    uint256 public startTime; // Presale start time\n    uint256 public PERIOD; // Presale Period\n    address payable public multiSigAdmin; // MultiSig contract address : The address where to withdraw funds token to after presale\n\n    bool private isPresaleStarted;\n    uint256 public soldStripAmount;\n\n    IStripToken public stripToken; // Rewards Token : Token for distribution as rewards.\n    IVesting private vestingContract; // Vesting Contract\n\n    event PrevParticipantsRegistered(address[], uint256[],  uint256[]);\n    event PresaleRegistered(address _registeredAddress, uint256 _weiAmount, uint256 _stripAmount);\n    event PresaleStarted(uint256 _startTime);\n    event PresalePaused(uint256 _endTime);\n    event PresalePeriodUpdated(uint256 _newPeriod);\n    event MultiSigAdminUpdated(address _multiSigAdmin);\n\n    /********************** Modifiers ***********************/\n    modifier onlyOwner() {\n        require(owner == msg.sender, \"Requires Owner Role\");\n        _;\n    }\n\n    modifier whileOnGoing() {\n        require(block.timestamp >= startTime, \"Presale has not started yet\");\n        require(block.timestamp <= startTime + PERIOD, \"Presale has ended\");\n        require(isPresaleStarted, \"Presale has ended or paused\");\n        _;\n    }\n\n    modifier whileFinished() {\n        require(block.timestamp > startTime + PERIOD, \"Presale has not ended yet!\");\n        _;\n    }\n\n    modifier whileDeposited() {\n        require(getDepositedStrip() >= IDS, \"Deposit enough Strip tokens to the vesting contract first!\");\n        _;\n    }\n\n    constructor(address _stripToken, address payable _multiSigAdmin) {\n        owner = msg.sender;\n\n        stripToken = IStripToken(_stripToken);\n        multiSigAdmin = _multiSigAdmin;\n        PERIOD = 2 weeks;\n\n        isPresaleStarted = false;\n    }\n\n    /********************** Internal ***********************/\n    \n    /**\n     * @dev Get the StripToken amount of vesting contract\n     */\n    function getDepositedStrip() internal view returns (uint256) {\n        address addrVesting = address(vestingContract);\n        return stripToken.balanceOf(addrVesting);\n    }\n\n    /**\n     * @dev Get remaining StripToken amount of vesting contract\n     */\n    function getUnsoldStrip() internal view returns (uint256) {\n        uint256 totalDepositedStrip = getDepositedStrip();\n        return totalDepositedStrip.sub(soldStripAmount);\n    }\n\n    /********************** External ***********************/\n    \n    function remainingStrip() external view returns (uint256) {\n        return getUnsoldStrip();\n    }\n\n    function isPresaleGoing() external view returns (bool) {\n        return isPresaleStarted && block.timestamp >= startTime && block.timestamp <= startTime + PERIOD;\n    }\n\n    /**\n     * @dev Start presale after checking if there's enough strip in vesting contract\n     */\n    function startPresale() external whileDeposited onlyOwner {\n        require(!isPresaleStarted, \"StartPresale: Presale has already started!\");\n        isPresaleStarted = true;\n        startTime = block.timestamp;\n        emit PresaleStarted(startTime);\n    }\n\n    /**\n     * @dev Update Presale period\n     */\n    function setPresalePeriod(uint256 _newPeriod) external whileDeposited onlyOwner {\n        PERIOD = _newPeriod;\n        emit PresalePeriodUpdated(PERIOD);\n    }\n\n    /**\n     * @dev Pause the ongoing presale by emergency\n     */\n    function pausePresaleByEmergency() external onlyOwner {\n        isPresaleStarted = false;\n        emit PresalePaused(block.timestamp);\n    }\n\n    /**\n     * @dev All remaining funds will be sent to multiSig admin  \n     */\n    function setMultiSigAdminAddress(address payable _multiSigAdmin) external onlyOwner {\n        require (_multiSigAdmin != address(0x00));\n        multiSigAdmin = _multiSigAdmin;\n        emit MultiSigAdminUpdated(multiSigAdmin);\n    }\n\n    function setStripTokenAddress(address _stripToken) external onlyOwner {\n        require (_stripToken != address(0x00));\n        stripToken = IStripToken(_stripToken);\n    }\n\n    function setVestingContractAddress(address _vestingContract) external onlyOwner {\n        require (_vestingContract != address(0x00));\n        vestingContract = IVesting(_vestingContract);\n    }\n\n    /** \n     * @dev After presale ends, we withdraw funds to the multiSig admin\n     */ \n    function withdrawRemainingFunds() external whileFinished onlyOwner returns (uint256) {\n        require(multiSigAdmin != address(0x00), \"Withdraw: Project Owner address hasn't been set!\");\n\n        uint256 weiBalance = address(this).balance;\n        require(weiBalance > 0, \"Withdraw: No ETH balance to withdraw\");\n\n        (bool sent, ) = multiSigAdmin.call{value: weiBalance}(\"\");\n        require(sent, \"Withdraw: Failed to withdraw remaining funds\");\n       \n        return weiBalance;\n    }\n\n    /**\n     * @dev After presale ends, we withdraw unsold StripToken to multisig\n     */ \n    function withdrawUnsoldStripToken() external whileFinished onlyOwner returns (uint256) {\n        require(multiSigAdmin != address(0x00), \"Withdraw: Project Owner address hasn't been set!\");\n        require(address(vestingContract) != address(0x00), \"Withdraw: Set vesting contract!\");\n\n        uint256 unsoldStrip = getUnsoldStrip();\n\n        require(\n            stripToken.transferFrom(address(vestingContract), multiSigAdmin, unsoldStrip),\n            \"Withdraw: can't withdraw Strip tokens\"\n        );\n\n        return unsoldStrip;\n    }\n\n    /**\n     * @dev Receive Wei from presale buyers\n     */ \n    function deposit(address sender) external payable whileOnGoing returns (uint256) {\n        require(sender != address(0x00), \"Deposit: Sender should be valid address\");\n        require(multiSigAdmin != address(0x00), \"Deposit: Project Owner address hasn't been set!\");\n        require(address(vestingContract) != address(0x00), \"Withdraw: Set vesting contract!\");\n        \n        uint256 weiAmount = msg.value;\n        uint256 newDepositedWei = recipients[sender].amountDepositedWei.add(weiAmount);\n        uint256 weiWithoutTax = weiAmount.mul(100).div(101);   // 1% of tax for each purchase\n\n        require(MAX_ALLOC_WEI >= newDepositedWei, \"Deposit: Can't exceed the MAX_ALLOC!\");\n\n        uint256 newStripAmount = weiWithoutTax.mul(MAX_ALLOC_STRIP).div(5e17);\n        require(soldStripAmount + newStripAmount <= IDS, \"Deposit: All sold out\");\n\n        recipients[sender].amountDepositedWei = newDepositedWei;\n        soldStripAmount = soldStripAmount.add(newStripAmount);\n\n        recipients[sender].amountStrip = recipients[sender].amountStrip.add(newStripAmount);\n        vestingContract.addNewRecipient(sender, recipients[sender].amountStrip, true);\n\n        require(weiAmount > 0, \"Deposit: No ETH balance to withdraw\");\n\n        (bool sent, ) = multiSigAdmin.call{value: weiAmount}(\"\");\n        require(sent, \"Deposit: Failed to send Ether\");\n\n        emit PresaleRegistered(sender, weiAmount, recipients[sender].amountStrip);\n\n        return recipients[sender].amountStrip;\n    }\n\n\n    /**\n     * @dev Update the data of participants who participated in presale before \n     * @param _oldRecipients the addresses to be added\n     * @param _weiAmounts integer array to indicate wei amount of participants\n     * @param _tokenAmounts integer array to indicate strip amount of participants\n     */\n\n    function addPreviousParticipants(address[] memory _oldRecipients, uint256[] memory _weiAmounts, uint256[] memory _tokenAmounts) external onlyOwner {\n        for (uint256 i = 0; i < _oldRecipients.length; i++) {\n            require(_weiAmounts[i] <= MAX_ALLOC_WEI, \"addPreviousParticipants: Wei amount exceeds limit\");\n            require(_tokenAmounts[i] <= MAX_ALLOC_STRIP, \"addPreviousParticipants: Token amount exceeds limit\");\n            recipients[_oldRecipients[i]].amountDepositedWei = recipients[_oldRecipients[i]].amountDepositedWei.add(_weiAmounts[i]);\n            recipients[_oldRecipients[i]].amountStrip = recipients[_oldRecipients[i]].amountStrip.add(_tokenAmounts[i]);\n            soldStripAmount = soldStripAmount.add(_tokenAmounts[i]);\n        }\n\n        emit PrevParticipantsRegistered(_oldRecipients, _weiAmounts, _tokenAmounts);\n    }\n}\n\n"
    },
    "contracts/interfaces/IStripToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IStripToken is IERC20 {\n    function decimals() external view returns (uint256);\n    function setMultiSigAdminAddress(address) external;\n    function recoverERC20(address, uint256) external;\n}\n"
    },
    "contracts/interfaces/IVesting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IVesting {\n    function setVestingAllocation(uint256) external;\n    function addNewRecipient(address, uint256, bool) external;\n    function addNewRecipients(address[] memory, uint256[] memory, bool) external;\n    function startVesting(uint256) external;\n    function getLocked(address) external view returns (uint256);\n    function getWithdrawable(address) external view returns (uint256);\n    function withdrawToken(address) external returns (uint256);\n    function getVested(address) external view returns (uint256);\n}\n"
    }
  }
}}