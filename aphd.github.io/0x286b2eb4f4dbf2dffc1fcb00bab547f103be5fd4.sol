{"interfaces.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller\u0027s account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller\u0027s tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender\u0027s allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller\u0027s\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\n// Reflection\ninterface IReflect {\n    function tokenFromReflection(uint256 rAmount)\n        external\n        view\n        returns (uint256);\n\n    function reflectionFromToken(uint256 tAmount, bool deductTransferFee)\n        external\n        view\n        returns (uint256);\n\n    function getRate() external view returns (uint256);\n}\n\n/// ChainLink ETH/USD oracle\ninterface IChainLink {\n    // chainlink ETH/USD oracle\n    // answer|int256 :  216182781556 - 8 decimals\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n\n/// USDT is not ERC-20 compliant, not returning true on transfers\ninterface IUsdt {\n    function transfer(address, uint256) external;\n\n    function transferFrom(\n        address,\n        address,\n        uint256\n    ) external;\n}\n\n// Check ETH send to first presale\n// Yes, there is a typo\ninterface IPresale1 {\n    function blanceOf(address user) external view returns (uint256 amt);\n}\n\n// Check tokens bought in second presale\n// There is bug in ETH deposits, we need handle it\n// Also \"tokensBoughtOf\" calculation is broken, so we do all math\ninterface IPresale2 {\n    function ethDepositOf(address user) external view returns (uint256 amt);\n\n    function usdDepositOf(address user) external view returns (uint256 amt);\n}\n\n// Check final sale tokens bought\ninterface ISale {\n    function tokensBoughtOf(address user) external view returns (uint256 amt);\n}\n\ninterface IClaimSale {\n    function addLock(\n        address user,\n        uint256 reflection,\n        uint256 locktime\n    ) external;\n}\n"},"owned.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\ncontract Owned {\n    address public owner;\n    address public newOwner;\n\n    event OwnershipChanged(address from, address to);\n\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipChanged(address(0), msg.sender);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    // owner can give super-rights to someone\n    function giveOwnership(address user) external onlyOwner {\n        require(user != address(0), \"User renounceOwnership\");\n        newOwner = user;\n    }\n\n    // new owner need to accept\n    function acceptOwnership() external {\n        require(msg.sender == newOwner, \"Only NewOwner\");\n        emit OwnershipChanged(owner, newOwner);\n        owner = msg.sender;\n        delete newOwner;\n    }\n}\n"},"public-sale.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\n/**\nApes Together Strong!\n\nAbout BigShortBets DeFi project:\n\nWe are creating a social\u0026trading p2p platform that guarantees encrypted interaction between investors.\nLogging in is possible via a cryptocurrency wallet (e.g. Metamask).\nThe security level is one comparable to the Tor network.\n\nhttps://bigsb.io/ - Our Tool\nhttps://bigshortbets.com - Project\u0026Team info\n\nVideo explainer:\nhttps://youtu.be/wbhUo5IvKdk\n\nZaorski, You Son of a bitch I’m in …\n*/\n\npragma solidity 0.8.7;\nimport \"./owned.sol\";\nimport \"./reentryGuard.sol\";\nimport \"./interfaces.sol\";\n\ncontract BigSBPublicSale is Owned, Guarded {\n    constructor(\n        address usdc,\n        address usdt,\n        address dai,\n        address token,\n        address oracle,\n        uint256 amlLimit,\n        Step[] memory steps\n    ) {\n        DAI = dai;\n        USDT = usdt;\n        USDC = usdc;\n        BigSBaddress = token;\n        ChainLinkOracle = oracle;\n        uint256 i;\n        for (i; i \u003c steps.length; i++) {\n            saleSteps.push(steps[i]);\n        }\n        // sale ends in 2 years\n        saleEnd = block.timestamp + 730 days;\n        maxDollarsPerUser = amlLimit;\n    }\n\n    // Claim contract that earn from fees\n    address public claimContract;\n\n    /// Struct decribing sale steps\n    struct Step {\n        uint256 lockLength; // how long tokens will be locked in contract (time in seconds)\n        uint256 maxTokensPerUSD; // initial, maximum tokens per USD (min price)\n        uint256 tokensPerUSD; // price in for given step\n        uint256 tokenAmount; // how much tokens left on sale in this step (18 decimals)\n    }\n\n    /// Array of sale steps\n    Step[] public saleSteps;\n\n    /// last used step to not iterate full array every time\n    uint256 public currentSaleStep;\n\n    /// token address\n    address public immutable BigSBaddress;\n\n    /// Contract to get current ETH price\n    address public immutable ChainLinkOracle;\n\n    // stablecoins addresses\n    address public immutable DAI;\n    address public immutable USDT;\n    address public immutable USDC;\n\n    /// dollars per user\n    mapping(address =\u003e uint256) public dollarsIn;\n\n    /// aml limit (6 decimals)\n    uint256 public maxDollarsPerUser;\n\n    /// timestamp when owner can take all not sold tokens\n    uint256 public immutable saleEnd;\n\n    // ETH buy functions need 200k gas limit\n    receive() external payable {\n        _buyEth();\n    }\n\n    /// buy for ETH using DApp\n    function buyEth() external payable {\n        _buyEth();\n    }\n\n    // Calculate USD value and make transaction if possible\n    function _buyEth() internal guarded {\n        uint256 price = EthPrice();\n        uint256 dollars = (msg.value * price) / 1 ether;\n        uint256 refund = _buy(dollars);\n        if (refund \u003e 0) {\n            require(\n                payable(msg.sender).send((refund * 1 ether) / price),\n                \"Refund failed\"\n            );\n        }\n    }\n\n    // Stablecoins buy need 300k gas limit\n\n    /// buy for USDT using DApp, need approve first!\n    function buyUsdt(uint256 amt) external guarded {\n        // accept USDT token, it is not proper ERC20\n        IUsdt(USDT).transferFrom(msg.sender, address(this), amt);\n        uint256 refund = _buy(amt);\n        if (refund \u003e 0) {\n            IUsdt(USDT).transfer(msg.sender, refund);\n        }\n    }\n\n    /// buy for DAI using DApp, need approve first!\n    function buyDai(uint256 amt) external guarded {\n        // accept DAI token\n        require(\n            IERC20(DAI).transferFrom(msg.sender, address(this), amt),\n            \"DAI transfer failed\"\n        );\n        // dai uses 18 decimals, we need only 6\n        uint256 refund = _buy(amt / (10**12));\n        if (refund \u003e 0) {\n            require(\n                IERC20(DAI).transfer(msg.sender, refund * 10**12),\n                \"Refund failed\"\n            );\n        }\n    }\n\n    /// buy for USDC using DApp, need approve first!\n    function buyUsdc(uint256 amt) external guarded {\n        // accept USDC token\n        require(\n            IERC20(USDC).transferFrom(msg.sender, address(this), amt),\n            \"USDC transfer failed\"\n        );\n        uint256 refund = _buy(amt);\n        if (refund \u003e 0) {\n            require(IERC20(USDC).transfer(msg.sender, refund), \"Refund failed\");\n        }\n    }\n\n    // buy tokens for current step price\n    // dollars with 6 decimals\n    // move to next step if needed\n    // make separate locks if passing threshold\n    function _buy(uint256 dollars) internal returns (uint256 refund) {\n        require(currentSaleStep \u003c saleSteps.length, \"Sale is over\");\n        require(claimContract != address(0), \"Claim not configured\");\n        uint256 sum = dollarsIn[msg.sender] + dollars;\n        require(sum \u003c maxDollarsPerUser, \"Over AML limit\");\n        dollarsIn[msg.sender] = sum;\n\n        uint256 numLocks;\n\n        Step memory s = saleSteps[currentSaleStep];\n        uint256 tokens = (dollars * s.tokensPerUSD) / 1000000;\n        uint256 timeNow = block.timestamp;\n        uint256 toSale = s.tokenAmount;\n\n        uint256 toSend;\n\n        // check for step change\n        if (tokens \u003e toSale) {\n            // set user lock at this step\n            uint256 reflection = IReflect(BigSBaddress).reflectionFromToken(\n                toSale,\n                false\n            );\n            IClaimSale(claimContract).addLock(\n                msg.sender,\n                reflection,\n                timeNow + s.lockLength\n            );\n\n            numLocks++;\n            toSend = toSale;\n            // no more for this price\n            saleSteps[currentSaleStep].tokenAmount = 0;\n\n            // calculate remaning USD\n            dollars = ((tokens - toSale) * 1000000) / s.tokensPerUSD;\n            // advance to next sale step\n            currentSaleStep++;\n            if (currentSaleStep == saleSteps.length) {\n                // send tokens to claim contract\n                require(\n                    IERC20(BigSBaddress).transfer(claimContract, toSend),\n                    \"Transfer failed\"\n                );\n                // no more steps, refund whats left\n                return dollars;\n            }\n            // recalculate tokens\n            tokens =\n                (dollars * saleSteps[currentSaleStep].tokensPerUSD) /\n                1000000;\n        }\n\n        // do not add empty lock\n        if (tokens \u003e 0) {\n            uint256 amt = IReflect(BigSBaddress).reflectionFromToken(\n                tokens,\n                false\n            );\n\n            saleSteps[currentSaleStep].tokenAmount -= tokens;\n            // make user lock\n            IClaimSale(claimContract).addLock(\n                msg.sender,\n                amt,\n                saleSteps[currentSaleStep].lockLength + timeNow\n            );\n            numLocks++;\n            toSend += tokens;\n        }\n        // ensure any lock is added\n        require(numLocks \u003e 0, \"Nothing sold\");\n        require(\n            IERC20(BigSBaddress).transfer(claimContract, toSend),\n            \"Transfer failed\"\n        );\n        return 0;\n    }\n\n    //\n    // Viewers\n    //\n\n    /**\n        What is current token price?\n     */\n    function currentPrice() external view returns (uint256) {\n        return saleSteps[currentSaleStep].tokensPerUSD;\n    }\n\n    /**\n        How many tokens left on current price?\n    */\n    function tokensLeftInStep() external view returns (uint256) {\n        if (currentSaleStep \u003c saleSteps.length) {\n            return saleSteps[currentSaleStep].tokenAmount;\n        } else return 0;\n    }\n\n    /**\n    Get ETH price from Chainlink.\n    @return ETH price in USD with 6 decimals\n    */\n    function EthPrice() public view returns (uint256) {\n        int256 answer;\n        (, answer, , , ) = IChainLink(ChainLinkOracle).latestRoundData();\n        // answer is 8 decimals, we need 6 as in stablecoins\n        return uint256(answer / 100);\n    }\n\n    //\n    // Rick mode\n    //\n\n    // Set claim contract address (once)\n    function setClaimContract(address claimAddress) external onlyOwner {\n        require(claimContract == address(0), \"Already set\");\n        claimContract = claimAddress;\n    }\n\n    /**\n        Update sale ratio of next sale step when needed\n        Can be only lower than configured on deploy\n        @param tokensPerUSD updated ratio\n    */\n    function updatePrice(uint256 tokensPerUSD) external onlyOwner {\n        require(\n            tokensPerUSD \u003c= saleSteps[currentSaleStep + 1].maxTokensPerUSD,\n            \"Too high ratio\"\n        );\n        saleSteps[currentSaleStep + 1].tokensPerUSD = tokensPerUSD;\n    }\n\n    /**\n        Set AML limit in USD with 6 decimals\n    */\n    function updateUsdLimit(uint256 limit) external onlyOwner {\n        maxDollarsPerUser = limit;\n    }\n\n    /**\n        Take ETH from contract\n    */\n    function withdrawEth() external onlyOwner {\n        payable(owner).transfer(address(this).balance);\n    }\n\n    /**\n        Take any ERC20 from contract (excl BigSB)\n    */\n    function withdrawErc20(address token) external onlyOwner {\n        require(token != BigSBaddress, \"Lol, no\");\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        require(balance \u003e 0, \"Nothing to withdraw\");\n        // use broken IERC20\n        IUsdt(token).transfer(owner, balance);\n    }\n\n    /// emergency token withdraw possible after 2 years\n    function withdrawBigSB(uint256 amt) external onlyOwner {\n        require(block.timestamp \u003e saleEnd, \"Too soon\");\n        uint256 balance = IERC20(BigSBaddress).balanceOf(address(this));\n        require(amt \u003c= balance, \"Too much\");\n        require(IERC20(BigSBaddress).transfer(owner, amt), \"Transfer failed\");\n    }\n}\n\n//This is fine!\n"},"reentryGuard.sol":{"content":"// SPDX-License-Identifier: UNLICENSE\n\npragma solidity ^0.8.7;\n\ncontract Guarded {\n    uint256 constant NOT_ENTERED = 1;\n    uint256 constant ENTERED = 2;\n    uint256 entryState = NOT_ENTERED;\n\n    modifier guarded() {\n        require(entryState == NOT_ENTERED, \"Reentry\");\n        entryState = ENTERED;\n        _;\n        entryState = NOT_ENTERED;\n    }\n}\n"}}