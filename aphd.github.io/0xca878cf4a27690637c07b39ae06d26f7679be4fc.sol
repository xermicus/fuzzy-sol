{"Context.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"},"FluxAggregatorSweeper.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\nimport \"./IFluxAggregator.sol\";\nimport \"./Sweeper.sol\";\n\n/**\n * @title FluxAggregatorSweeper\n * @dev Handles withdrawing of rewards from flux aggregator Chainlink contracts.\n */\ncontract FluxAggregatorSweeper is Sweeper {\n    address public oracle;\n\n    constructor(\n        address _nodeRewards,\n        uint256 _minTowithdraw,\n        address _oracle\n    ) Sweeper(_nodeRewards, _minTowithdraw) {\n        oracle = _oracle;\n    }\n\n    /**\n     * @dev returns withdrawable amount for each flux aggregator\n     * @return withdrawable balance of each flux aggregator\n     **/\n    function withdrawable() external view override returns (uint256[] memory) {\n        uint256[] memory _withdrawable = new uint256[](contracts.length);\n        for (uint i = 0; i \u003c contracts.length; i++) {\n            _withdrawable[i] = IFluxAggregator(contracts[i]).withdrawablePayment(oracle);\n        }\n        return _withdrawable;\n    }\n\n    /**\n     * @dev withdraw rewards from flux aggregators\n     * @param _contractIdxs indexes corresponding to the flux aggregators\n     **/\n    function _withdraw(uint256[] calldata _contractIdxs) internal override {\n        for (uint i = 0; i \u003c _contractIdxs.length; i++) {\n            require(_contractIdxs[i] \u003c contracts.length, \"contractIdx must be \u003c contracts length\");\n            IFluxAggregator aggregator = IFluxAggregator(contracts[_contractIdxs[i]]);\n            uint256 amount = aggregator.withdrawablePayment(oracle);\n            if (amount \u003e= minToWithdraw) {\n                aggregator.withdrawPayment(oracle, msg.sender, amount);\n            }\n        }\n    }\n\n    /**\n     * @dev transfers admin to new address for selected flux aggregators\n     * @param _contractIdxs indexes corresponsing to flux aggregators\n     * @param _newAdmin address to transfer admin to\n     **/\n    function _transferAdmin(uint256[] calldata _contractIdxs, address _newAdmin) internal override {\n        for (uint i = 0; i \u003c _contractIdxs.length; i++) {\n            require(_contractIdxs[i] \u003c contracts.length, \"contractIdx must be \u003c contracts length\");\n            IFluxAggregator(contracts[_contractIdxs[i]]).transferAdmin(oracle, _newAdmin);\n        }\n    }\n\n    /**\n     * @dev accepts admin for flux aggregators\n     * @param _contractIdxs corresponding to the flux aggregators\n     **/\n    function _acceptAdmin(uint256[] calldata _contractIdxs) internal override {\n        for (uint i = 0; i \u003c _contractIdxs.length; i++) {\n            require(_contractIdxs[i] \u003c contracts.length, \"contractIdx must be \u003c contracts length\");\n            IFluxAggregator(contracts[_contractIdxs[i]]).acceptAdmin(oracle);\n        }\n    }\n}\n"},"IFluxAggregator.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\ninterface IFluxAggregator {\n    function withdrawablePayment(address _oracle) external view returns (uint256);\n\n    function withdrawPayment(\n        address _oracle,\n        address _recipient,\n        uint256 _amount\n    ) external;\n\n    function transferAdmin(address _oracle, address _newAdmin) external;\n\n    function acceptAdmin(address _oracle) external;\n}\n"},"Ownable.sol":{"content":"// SPDX-License-Identifier: MIT\n\npragma solidity \u003e=0.6.0 \u003c0.8.0;\n\nimport \"./Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"},"Sweeper.sol":{"content":"// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.7.4;\n\nimport \"./Ownable.sol\";\n\n/**\n * @title Sweeper\n * @dev Base sweeper contract that other sweeper contracts should inherit from\n */\nabstract contract Sweeper is Ownable {\n    uint256 public minToWithdraw;\n\n    address[] public contracts;\n    address nodeRewards;\n\n    modifier onlyNodeRewards() {\n        require(nodeRewards == msg.sender, \"NodeRewards only\");\n        _;\n    }\n\n    constructor(address _nodeRewards, uint256 _minToWithdraw) {\n        nodeRewards = _nodeRewards;\n        minToWithdraw = _minToWithdraw;\n    }\n\n    /**\n     * @dev returns current list of contracts\n     * @return list of contracts\n     **/\n    function getContracts() external view returns (address[] memory) {\n        return contracts;\n    }\n\n    /**\n     * @dev withdraws rewards from contracts\n     * @param _contractIdxs indexes corresponding to the contracts\n     **/\n    function withdraw(uint256[] calldata _contractIdxs) external virtual onlyNodeRewards() {\n        require(_contractIdxs.length \u003c= contracts.length, \"contractIdxs length must be \u003c= contracts length\");\n        _withdraw(_contractIdxs);\n    }\n\n    /**\n     * @dev returns the withdrawable amount for each contract\n     * @return withdrawable balance of each contract\n     **/\n    function withdrawable() external view virtual returns (uint256[] memory);\n\n    /**\n     * @dev transfers admin to new address for selected contracts\n     * @param _contractIdxs indexes corresponsing to contracts\n     * @param _newAdmin address to transfer admin to\n     **/\n    function transferAdmin(uint256[] calldata _contractIdxs, address _newAdmin) external onlyOwner() {\n        require(_contractIdxs.length \u003c= contracts.length, \"contractIdxs length must be \u003c= contracts length\");\n        _transferAdmin(_contractIdxs, _newAdmin);\n    }\n\n    /**\n     * @dev accepts admin transfer for selected contracts\n     * @param _contractIdxs indexes corresponsing to contracts\n     **/\n    function acceptAdmin(uint256[] calldata _contractIdxs) external onlyOwner() {\n        require(_contractIdxs.length \u003c= contracts.length, \"contractIdxs length must be \u003c= contracts length\");\n        _acceptAdmin(_contractIdxs);\n    }\n\n    /**\n     * @dev sets the minimum amount needed to withdraw for each contract\n     * @param _minToWithdraw amount to set\n     **/\n    function setMinToWithdraw(uint256 _minToWithdraw) external onlyOwner() {\n        minToWithdraw = _minToWithdraw;\n    }\n\n    /**\n     * @dev adds contract addresses\n     * @param _contracts contracts to add\n     **/\n    function addContracts(address[] calldata _contracts) external onlyOwner() {\n        for (uint i = 0; i \u003c _contracts.length; i++) {\n            contracts.push(_contracts[i]);\n        }\n    }\n\n    /**\n     * @dev removes contract address\n     * @param _index index of contract to remove\n     **/\n    function removeContract(uint256 _index) external onlyOwner() {\n        require(_index \u003c contracts.length, \"Contract does not exist\");\n\n        contracts[_index] = contracts[contracts.length - 1];\n        delete contracts[contracts.length - 1];\n    }\n\n    /**\n     * @dev withdraws rewards from contracts\n     * @param _contractIdxs indexes corresponding to the contracts\n     **/\n    function _withdraw(uint256[] calldata _contractIdxs) internal virtual;\n\n    /**\n     * @dev transfers admin to new address for selected contracts\n     * @param _contractIdxs indexes corresponsing to contracts\n     * @param _newAdmin address to transfer admin to\n     **/\n    function _transferAdmin(uint256[] calldata _contractIdxs, address _newAdmin) internal virtual;\n\n    /**\n     * @dev accepts admin transfer for selected contracts\n     * @param _contractIdxs indexes corresponsing to contracts\n     **/\n    function _acceptAdmin(uint256[] calldata _contractIdxs) internal virtual {}\n}\n"}}